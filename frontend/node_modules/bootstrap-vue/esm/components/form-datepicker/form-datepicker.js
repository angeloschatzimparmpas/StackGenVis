function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import Vue from '../../utils/vue';
import identity from '../../utils/identity';
import { getComponentConfig } from '../../utils/config';
import { createDate, formatYMD, parseYMD } from '../../utils/date';
import dropdownMixin from '../../mixins/dropdown';
import idMixin from '../../mixins/id';
import { BButton } from '../button/button';
import { BCalendar } from '../calendar/calendar';
import { BIconCalendar, BIconCalendarFill } from '../../icons/icons';
import { VBHover } from '../../directives/hover/hover';
var NAME = 'BFormDatepicker'; // Fallback to BCalendar prop if no value found

var getConfigFallback = function getConfigFallback(prop) {
  return getComponentConfig(NAME, prop) || getComponentConfig('BCalendar', prop);
}; // We create our props as a mixin so that we can control
// where they appear in the props listing reference section


var propsMixin = {
  props: {
    value: {
      type: [String, Date],
      default: null
    },
    valueAsDate: {
      type: Boolean,
      default: false
    },
    resetValue: {
      type: [String, Date],
      default: ''
    },
    placeholder: {
      type: String,
      // Defaults to `labelNoDateSelected` from calendar context
      default: null
    },
    size: {
      type: String,
      default: null
    },
    min: {
      type: [String, Date],
      default: null
    },
    max: {
      type: [String, Date],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    required: {
      // If true adds the `aria-required` attribute
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: null
    },
    form: {
      type: String,
      default: null
    },
    state: {
      // Tri-state prop: `true`, `false` or `null`
      type: Boolean,
      default: null
    },
    dateDisabledFn: {
      type: Function,
      default: null
    },
    noCloseOnSelect: {
      type: Boolean,
      default: false
    },
    hideHeader: {
      type: Boolean,
      default: false
    },
    locale: {
      type: [String, Array],
      default: null
    },
    startWeekday: {
      // `0` (Sunday), `1` (Monday), ... `6` (Saturday)
      // Day of week to start calendar on
      type: [Number, String],
      default: 0
    },
    direction: {
      type: String,
      default: null
    },
    selectedVariant: {
      // Variant color to use for the selected date
      type: String,
      default: 'primary'
    },
    todayVariant: {
      // Variant color to use for today's date (defaults to `variant`)
      type: String,
      default: null
    },
    noHighlightToday: {
      // Disable highlighting today's date
      type: Boolean,
      default: false
    },
    todayButton: {
      type: Boolean,
      default: false
    },
    labelTodayButton: {
      type: String,
      default: function _default() {
        return getComponentConfig(NAME, 'labelTodayButton');
      }
    },
    todayButtonVariant: {
      type: String,
      default: 'outline-primary'
    },
    resetButton: {
      type: Boolean,
      default: false
    },
    labelResetButton: {
      type: String,
      default: function _default() {
        return getComponentConfig(NAME, 'labelResetButton');
      }
    },
    resetButtonVariant: {
      type: String,
      default: 'outline-danger'
    },
    closeButton: {
      type: Boolean,
      default: false
    },
    labelCloseButton: {
      type: String,
      default: function _default() {
        return getComponentConfig(NAME, 'labelCloseButton');
      }
    },
    closeButtonVariant: {
      type: String,
      default: 'outline-secondary'
    },
    // Labels for buttons and keyboard shortcuts
    // These pick BCalendar global config if no BFormDate global config
    labelPrevYear: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelPrevYear');
      }
    },
    labelPrevMonth: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelPrevMonth');
      }
    },
    labelCurrentMonth: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelCurrentMonth');
      }
    },
    labelNextMonth: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelNextMonth');
      }
    },
    labelNextYear: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelNextYear');
      }
    },
    labelToday: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelToday');
      }
    },
    labelSelected: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelSelected');
      }
    },
    labelNoDateSelected: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelNoDateSelected');
      }
    },
    labelCalendar: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelCalendar');
      }
    },
    labelNav: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelNav');
      }
    },
    labelHelp: {
      type: String,
      default: function _default() {
        return getConfigFallback('labelHelp');
      }
    },
    // Dark mode
    dark: {
      type: Boolean,
      default: false
    }
  }
}; // --- BFormDate component ---
// @vue/component

export var BFormDatepicker =
/*#__PURE__*/
Vue.extend({
  name: NAME,
  directives: {
    BHover: VBHover
  },
  // The mixins order determines the order of appearance in the props reference section
  mixins: [idMixin, propsMixin, dropdownMixin],
  model: {
    prop: 'value',
    event: 'input'
  },
  data: function data() {
    return {
      // We always use `YYYY-MM-DD` value internally
      localYMD: formatYMD(this.value) || '',
      // Context data from BCalendar
      localLocale: null,
      isRTL: false,
      formatedValue: '',
      activeYMD: '',
      // Flag to add focus ring to outer wrapper
      hasFocus: false,
      // If the control is hovered
      isHovered: false
    };
  },
  computed: {
    calendarYM: function calendarYM() {
      // Returns the calendar year/month
      // Returns the `YYYY-MM` portion of the active calendar date
      return this.activeYMD.slice(0, -3);
    },
    calendarProps: function calendarProps() {
      // TODO: Make the ID's computed props
      var idLabel = this.safeId('_value_');
      var idWrapper = this.safeId('_b-form-date_');
      return {
        // id: this.safeId('_picker_'),
        ariaControls: [idLabel, idWrapper].filter(identity).join(' ') || null,
        value: this.localYMD,
        hidden: !this.visible,
        min: this.min,
        max: this.max,
        readonly: this.readonly,
        disabled: this.disabled,
        locale: this.locale,
        startWeekday: this.startWeekday,
        direction: this.direction,
        dateDisabledFn: this.dateDisabledFn,
        selectedVariant: this.selectedVariant,
        todayVariant: this.todayVariant,
        hideHeader: this.hideHeader,
        labelPrevYear: this.labelPrevYear,
        labelPrevMonth: this.labelPrevMonth,
        labelCurrentMonth: this.labelCurrentMonth,
        labelNextMonth: this.labelNextMonth,
        labelNextYear: this.labelNextYear,
        labelToday: this.labelToday,
        labelSelected: this.labelSelected,
        labelNoDateSelected: this.labelNoDateSelected,
        labelCalendar: this.labelCalendar,
        labelNav: this.labelNav,
        labelHelp: this.labelHelp
      };
    },
    computedResetValue: function computedResetValue() {
      return parseYMD(this.resetValue) || '';
    }
  },
  watch: {
    value: function value(newVal) {
      this.localYMD = formatYMD(newVal) || '';
    },
    localYMD: function localYMD(newVal) {
      this.$emit('input', this.valueAsDate ? parseYMD(newVal) || null : newVal || '');
    },
    calendarYM: function calendarYM(newVal, oldVal)
    /* istanbul ignore next */
    {
      // Displayed calendar month has changed
      // So possibly the calendar height has changed...
      // We need to update popper computed position
      if (newVal !== oldVal && oldVal) {
        this.updatePopper();
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$on('shown', function () {
      // May want to make an option to focus
      // the entire calendar (dropdown-menu) or just the date
      try {
        _this.$refs.calendar.focus();
      } catch (_unused) {}
    });
  },
  methods: {
    // Public methods
    focus: function focus() {
      if (!this.disabled) {
        try {
          // This assumes the toggle is an element and not a component
          this.$refs.toggle.focus();
        } catch (_unused2) {}
      }
    },
    blur: function blur() {
      if (!this.disabled) {
        try {
          // This assumes the toggle is an element and not a component
          this.$refs.toggle.blur();
        } catch (_unused3) {}
      }
    },
    // Private methods
    setAndClose: function setAndClose(ymd) {
      var _this2 = this;

      this.localYMD = ymd; // Close calendar popup, unless `noCloseOnSelect`

      if (!this.noCloseOnSelect) {
        this.$nextTick(function () {
          _this2.hide(true);
        });
      }
    },
    onSelected: function onSelected(ymd) {
      var _this3 = this;

      this.$nextTick(function () {
        _this3.setAndClose(ymd);
      });
    },
    onInput: function onInput(ymd) {
      if (this.localYMD !== ymd) {
        this.localYMD = ymd;
      }
    },
    onContext: function onContext(ctx) {
      var activeYMD = ctx.activeYMD,
          isRTL = ctx.isRTL,
          locale = ctx.locale,
          selectedYMD = ctx.selectedYMD,
          selectedFormatted = ctx.selectedFormatted;
      this.isRTL = isRTL;
      this.localLocale = locale;
      this.formattedValue = selectedFormatted;
      this.localYMD = selectedYMD;
      this.activeYMD = activeYMD; // Re-emit the context event

      this.$emit('context', ctx);
    },
    onTodayButton: function onTodayButton() {
      this.setAndClose(formatYMD(createDate()));
    },
    onResetButton: function onResetButton() {
      this.setAndClose(this.computedResetValue);
    },
    onCloseButton: function onCloseButton() {
      this.hide(true);
    },
    setFocus: function setFocus(evt) {
      this.hasFocus = evt.type === 'focus';
    },
    handleHover: function handleHover(hovered) {
      this.isHovered = hovered;
    }
  },
  render: function render(h) {
    var _class2, _ref;

    var size = this.size;
    var state = this.state;
    var localYMD = this.localYMD;
    var disabled = this.disabled;
    var readonly = this.readonly;
    var idButton = this.safeId();
    var idLabel = this.safeId('_value_');
    var idMenu = this.safeId('_dialog_');
    var idWrapper = this.safeId('_b-form-date_');
    var $button = h('div', {
      attrs: {
        'aria-hidden': 'true'
      }
    }, [this.isHovered || this.hasFocus ? h(BIconCalendarFill, {
      props: {
        scale: 1.25
      }
    }) : h(BIconCalendar, {
      props: {
        scale: 1.25
      }
    })]);
    $button = h('button', {
      ref: 'toggle',
      staticClass: 'btn border-0 h-auto py-0',
      class: _defineProperty({}, "btn-".concat(size), !!size),
      attrs: {
        id: idButton,
        type: 'button',
        disabled: disabled,
        'aria-haspopup': 'dialog',
        'aria-expanded': this.visible ? 'true' : 'false',
        'aria-invalid': state === false ? 'true' : null,
        'aria-required': this.required ? 'true' : null
      },
      on: {
        mousedown: this.onMousedown,
        click: this.toggle,
        keydown: this.toggle,
        // Handle ENTER, SPACE and DOWN
        '!focus': this.setFocus,
        '!blur': this.setFocus
      }
    }, [$button]); // Label as a "fake" input
    // This label will be read by screen readers when the button is focused

    var $input = h('label', {
      staticClass: 'form-control text-break text-wrap border-0 bg-transparent h-auto pl-1 m-0',
      class: (_class2 = {
        // Mute the text if showing the placeholder
        'text-muted': !localYMD
      }, _defineProperty(_class2, "form-control-".concat(size), !!size), _defineProperty(_class2, 'is-invalid', state === false), _defineProperty(_class2, 'is-valid', state === true), _class2),
      attrs: {
        id: idLabel,
        for: idButton,
        dir: this.isRTL ? 'rtl' : 'ltr',
        lang: this.localLocale || null,
        'aria-invalid': state === false ? 'true' : null,
        'aria-required': this.required ? 'true' : null
      },
      on: {
        // Disable bubbling of the click event to
        // prevent menu from closing and re-opening
        click: function click(evt)
        /* istanbul ignore next */
        {
          evt.stopPropagation();
        }
      }
    }, [// Add the formatted value or placeholder
    localYMD ? this.formattedValue : this.placeholder || this.labelNoDateSelected, // Add an sr-only 'selected date' label if a date is selected
    localYMD ? h('span', {
      staticClass: 'sr-only'
    }, " (".concat(this.labelSelected, ") ")) : h()]); // Optional footer buttons

    var $controls = [];

    if (this.todayButton) {
      var label = this.labelTodayButton;
      $controls.push(h(BButton, {
        props: {
          size: 'sm',
          disabled: disabled || readonly,
          variant: this.todayButtonVariant
        },
        attrs: {
          'aria-label': label || null
        },
        on: {
          click: this.onTodayButton
        }
      }, label));
    }

    if (this.resetButton) {
      var _label = this.labelResetButton;
      $controls.push(h(BButton, {
        props: {
          size: 'sm',
          disabled: disabled || readonly,
          variant: this.resetButtonVariant
        },
        attrs: {
          'aria-label': _label || null
        },
        on: {
          click: this.onResetButton
        }
      }, _label));
    }

    if (this.closeButton) {
      var _label2 = this.labelCloseButton;
      $controls.push(h(BButton, {
        props: {
          size: 'sm',
          disabled: this.disabled,
          variant: this.closeButtonVariant
        },
        attrs: {
          'aria-label': _label2 || null
        },
        on: {
          click: this.onCloseButton
        }
      }, _label2));
    }

    if ($controls.length > 0) {
      $controls = [h('div', {
        staticClass: 'b-form-date-controls d-flex flex-wrap',
        class: {
          'justify-content-between': $controls.length > 1,
          'justify-content-end': $controls.length < 2
        }
      }, $controls)];
    }

    var $calendar = h(BCalendar, {
      key: 'calendar',
      ref: 'calendar',
      staticClass: 'b-form-date-calendar',
      props: this.calendarProps,
      on: {
        selected: this.onSelected,
        input: this.onInput,
        context: this.onContext
      }
    }, $controls);
    var $menu = h('div', {
      ref: 'menu',
      staticClass: 'dropdown-menu p-2',
      class: {
        show: this.visible,
        'dropdown-menu-right': this.right,
        'bg-dark': this.dark,
        'text-light': this.dark
      },
      attrs: {
        id: idMenu,
        role: 'dialog',
        'aria-modal': 'false',
        'aria-labelledby': idLabel
      },
      on: {
        keydown: this.onKeydown // Handle ESC

      }
    }, [$calendar]);
    var $hidden = h();

    if (this.name && !disabled) {
      $hidden = h('input', {
        attrs: {
          type: 'hidden',
          name: this.name,
          form: this.form,
          value: localYMD || ''
        }
      });
    }

    return h('div', {
      staticClass: 'b-form-datepicker form-control dropdown h-auto p-0 d-flex',
      class: [this.directionClass, (_ref = {
        show: this.visible,
        focus: this.hasFocus
      }, _defineProperty(_ref, "form-control-".concat(size), !!size), _defineProperty(_ref, 'is-invalid', state === false), _defineProperty(_ref, 'is-valid', state === true), _ref)],
      attrs: {
        id: idWrapper,
        role: 'group',
        'aria-disabled': disabled,
        'aria-readonly': readonly && !disabled,
        'aria-labelledby': idLabel,
        'aria-invalid': state === false ? 'true' : null,
        'aria-required': this.required ? 'true' : null,
        // We don't want the flex order to change here
        // So we always use 'ltr'
        dir: 'ltr'
      },
      directives: [{
        name: 'b-hover',
        value: this.handleHover
      }]
    }, [$button, $hidden, $menu, $input]);
  }
});