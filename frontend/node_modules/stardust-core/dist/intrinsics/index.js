"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("../common");
var common_2 = require("../common");
// Global intrinsic functions.
var intrinsicFunctions = new common_1.Dictionary();
var intrinsicFunctionList = [];
var typeConversions = new common_1.Dictionary();
var constants = new common_1.Dictionary();
function getInternalName(func) {
    return "@" + func.name + ":" + func.argTypes.join(",") + ":" + func.returnType;
}
exports.getInternalName = getInternalName;
function getIntrinsicFunction(internalName) {
    if (!intrinsicFunctions.has(internalName)) {
        console.log(internalName);
    }
    return intrinsicFunctions.get(internalName);
}
exports.getIntrinsicFunction = getIntrinsicFunction;
function forEachIntrinsicFunction(callback) {
    intrinsicFunctionList.forEach(callback);
}
exports.forEachIntrinsicFunction = forEachIntrinsicFunction;
function addIntrinsicFunction(func) {
    func.internalName = getInternalName(func);
    intrinsicFunctions.set(func.internalName, func);
    intrinsicFunctionList.push(func);
}
exports.addIntrinsicFunction = addIntrinsicFunction;
function addConstant(name, type, value) {
    var constant = {
        name: name,
        type: type,
        value: value
    };
    constants.set(name, constant);
}
exports.addConstant = addConstant;
function forEachConstant(callback) {
    constants.forEach(callback);
}
exports.forEachConstant = forEachConstant;
function forEachTypeConversion(callback) {
    typeConversions.forEach(callback);
}
exports.forEachTypeConversion = forEachTypeConversion;
function getTypeConversion(srcType, destType) {
    return typeConversions.get(srcType + ":" + destType);
}
exports.getTypeConversion = getTypeConversion;
function RegisterTypeConversion(srcType, destType, rank, func) {
    var name = "cast:" + srcType + ":" + destType;
    var info = {
        name: name,
        argTypes: [srcType],
        returnType: destType,
        javascriptImplementation: func
    };
    addIntrinsicFunction(info);
    typeConversions.set(srcType + ":" + destType, {
        internalName: info.internalName,
        rank: rank
    });
}
function RegisterFunction(name, argTypes, returnType, func) {
    addIntrinsicFunction({
        name: name,
        argTypes: argTypes,
        returnType: returnType,
        javascriptImplementation: func
    });
}
function RegisterOperator(name, argTypes, returnType, func) {
    addIntrinsicFunction({
        name: "@" + name,
        argTypes: argTypes,
        returnType: returnType,
        javascriptImplementation: func
    });
}
function not_implemented() {
    throw new Error("not implemented");
}
var RegisterConstructor = function (type, srcTypes, func) { return RegisterFunction(type, srcTypes, type, func); };
// Basic arithmetics: +, -, *, /.
RegisterOperator("+", ["float", "float"], "float", function (a, b) { return a + b; });
RegisterOperator("-", ["float", "float"], "float", function (a, b) { return a - b; });
RegisterOperator("*", ["float", "float"], "float", function (a, b) { return a * b; });
RegisterOperator("/", ["float", "float"], "float", function (a, b) { return a / b; });
RegisterOperator("+", ["float"], "float", function (a) { return +a; });
RegisterOperator("-", ["float"], "float", function (a) { return -a; });
RegisterOperator("%", ["int", "int"], "int", function (a, b) { return a % b; });
RegisterOperator("%", ["float", "float"], "float", function (a, b) { return a % b; });
RegisterOperator("+", ["int", "int"], "int", function (a, b) { return a + b; });
RegisterOperator("-", ["int", "int"], "int", function (a, b) { return a - b; });
RegisterOperator("*", ["int", "int"], "int", function (a, b) { return a * b; });
RegisterOperator("/", ["int", "int"], "int", function (a, b) { return a / b; });
RegisterOperator("+", ["int"], "int", function (a) { return +a; });
RegisterOperator("-", ["int"], "int", function (a) { return -a; });
RegisterOperator("+", ["Vector2", "Vector2"], "Vector2", function (a, b) { return [a[0] + b[0], a[1] + b[1]]; });
RegisterOperator("-", ["Vector2", "Vector2"], "Vector2", function (a, b) { return [a[0] - b[0], a[1] - b[1]]; });
RegisterOperator("*", ["Vector2", "Vector2"], "Vector2", function (a, b) { return [a[0] * b[0], a[1] * b[1]]; });
RegisterOperator("/", ["Vector2", "Vector2"], "Vector2", function (a, b) { return [a[0] / b[0], a[1] / b[1]]; });
RegisterOperator("+", ["Vector2"], "Vector2", function (a) { return a; });
RegisterOperator("-", ["Vector2"], "Vector2", function (a) { return [-a[0], -a[1]]; });
RegisterOperator("+", ["Vector3", "Vector3"], "Vector3", function (a, b) { return [a[0] + b[0], a[1] + b[1], a[2] + b[2]]; });
RegisterOperator("-", ["Vector3", "Vector3"], "Vector3", function (a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; });
RegisterOperator("*", ["Vector3", "Vector3"], "Vector3", function (a, b) { return [a[0] * b[0], a[1] * b[1], a[2] * b[2]]; });
RegisterOperator("/", ["Vector3", "Vector3"], "Vector3", function (a, b) { return [a[0] / b[0], a[1] / b[1], a[2] / b[2]]; });
RegisterOperator("+", ["Vector3"], "Vector3", function (a) { return a; });
RegisterOperator("-", ["Vector3"], "Vector3", function (a) { return [
    -a[0],
    -a[1],
    -a[2]
]; });
RegisterOperator("+", ["Vector4", "Vector4"], "Vector4", function (a, b) { return [
    a[0] + b[0],
    a[1] + b[1],
    a[2] + b[2],
    a[3] + b[3]
]; });
RegisterOperator("-", ["Vector4", "Vector4"], "Vector4", function (a, b) { return [
    a[0] - b[0],
    a[1] - b[1],
    a[2] - b[2],
    a[3] - b[3]
]; });
RegisterOperator("*", ["Vector4", "Vector4"], "Vector4", function (a, b) { return [
    a[0] * b[0],
    a[1] * b[1],
    a[2] * b[2],
    a[3] * b[3]
]; });
RegisterOperator("/", ["Vector4", "Vector4"], "Vector4", function (a, b) { return [
    a[0] / b[0],
    a[1] / b[1],
    a[2] / b[2],
    a[3] / b[3]
]; });
RegisterOperator("+", ["Vector4"], "Vector4", function (a) { return a; });
RegisterOperator("-", ["Vector4"], "Vector4", function (a) { return [
    -a[0],
    -a[1],
    -a[2],
    -a[3]
]; });
RegisterOperator("*", ["float", "Vector2"], "Vector2", function (a, b) { return [a * b[0], a * b[1]]; });
RegisterOperator("*", ["Vector2", "float"], "Vector2", function (a, b) { return [a[0] * b, a[1] * b]; });
RegisterOperator("*", ["Vector2", "float"], "Vector2", function (a, b) { return [a[0] / b, a[1] / b]; });
RegisterOperator("*", ["float", "Vector3"], "Vector3", function (a, b) { return [a * b[0], a * b[1], a * b[2]]; });
RegisterOperator("*", ["Vector3", "float"], "Vector3", function (a, b) { return [a[0] * b, a[1] * b, a[2] * b]; });
RegisterOperator("*", ["Vector3", "float"], "Vector3", function (a, b) { return [a[0] / b, a[1] / b, a[2] / b]; });
RegisterOperator("*", ["float", "Vector4"], "Vector4", function (a, b) { return [a * b[0], a * b[1], a * b[2], a * b[3]]; });
RegisterOperator("*", ["Vector4", "float"], "Vector4", function (a, b) { return [a[0] * b, a[1] * b, a[2] * b, a[3] * b]; });
RegisterOperator("*", ["Vector4", "float"], "Vector4", function (a, b) { return [a[0] / b, a[1] / b, a[2] / b, a[3] / b]; });
// Comparison operators.
RegisterOperator("==", ["float", "float"], "bool", function (a, b) {
    return a == b ? 1 : 0;
});
RegisterOperator(">", ["float", "float"], "bool", function (a, b) {
    return a > b ? 1 : 0;
});
RegisterOperator("<", ["float", "float"], "bool", function (a, b) {
    return a < b ? 1 : 0;
});
RegisterOperator(">=", ["float", "float"], "bool", function (a, b) {
    return a >= b ? 1 : 0;
});
RegisterOperator("<=", ["float", "float"], "bool", function (a, b) {
    return a <= b ? 1 : 0;
});
RegisterOperator("==", ["int", "int"], "bool", function (a, b) {
    return a == b ? 1 : 0;
});
RegisterOperator(">", ["int", "int"], "bool", function (a, b) {
    return a > b ? 1 : 0;
});
RegisterOperator("<", ["int", "int"], "bool", function (a, b) {
    return a < b ? 1 : 0;
});
RegisterOperator(">=", ["int", "int"], "bool", function (a, b) {
    return a >= b ? 1 : 0;
});
RegisterOperator("<=", ["int", "int"], "bool", function (a, b) {
    return a <= b ? 1 : 0;
});
RegisterOperator("==", ["bool", "bool"], "bool", function (a, b) {
    return a == b ? 1 : 0;
});
// Boolean operators.
RegisterOperator("!", ["bool"], "bool", function (a) { return (!a ? 1 : 0); });
RegisterOperator("&&", ["bool", "bool"], "bool", function (a, b) {
    return a && b ? 1 : 0;
});
RegisterOperator("||", ["bool", "bool"], "bool", function (a, b) {
    return a || b ? 1 : 0;
});
// Vector/quaternion constructors.
RegisterConstructor("Vector2", ["float", "float"], function (a, b) { return [
    a,
    b
]; });
RegisterConstructor("Vector3", ["float", "float", "float"], function (a, b, c) { return [a, b, c]; });
RegisterConstructor("Vector4", ["float", "float", "float", "float"], function (a, b, c, d) { return [a, b, c, d]; });
RegisterConstructor("Color", ["float", "float", "float", "float"], function (a, b, c, d) { return [a, b, c, d]; });
RegisterConstructor("Quaternion", ["float", "float", "float", "float"], function (a, b, c, d) { return [a, b, c, d]; });
// Math functions.
RegisterFunction("abs", ["float"], "float", function (a) { return Math.abs(a); });
RegisterFunction("sqrt", ["float"], "float", function (a) { return Math.sqrt(a); });
RegisterFunction("exp", ["float"], "float", function (a) { return Math.exp(a); });
RegisterFunction("log", ["float"], "float", function (a) { return Math.log(a); });
RegisterFunction("sin", ["float"], "float", function (a) { return Math.sin(a); });
RegisterFunction("cos", ["float"], "float", function (a) { return Math.cos(a); });
RegisterFunction("tan", ["float"], "float", function (a) { return Math.tan(a); });
RegisterFunction("asin", ["float"], "float", function (a) { return Math.asin(a); });
RegisterFunction("acos", ["float"], "float", function (a) { return Math.acos(a); });
RegisterFunction("atan", ["float"], "float", function (a) { return Math.atan(a); });
RegisterFunction("atan2", ["float", "float"], "float", function (a, b) {
    return Math.atan2(a, b);
});
RegisterFunction("abs", ["int"], "int", function (a) { return Math.abs(a); });
RegisterFunction("min", ["int", "int"], "int", function (a, b) {
    return Math.min(a, b);
});
RegisterFunction("max", ["int", "int"], "int", function (a, b) {
    return Math.max(a, b);
});
RegisterFunction("min", ["float", "float"], "float", function (a, b) {
    return Math.min(a, b);
});
RegisterFunction("max", ["float", "float"], "float", function (a, b) {
    return Math.max(a, b);
});
RegisterFunction("ceil", ["float"], "float", function (a, b) {
    return Math.ceil(a);
});
RegisterFunction("floor", ["float"], "float", function (a, b) {
    return Math.floor(a);
});
RegisterFunction("mix", ["float", "float", "float"], "float", function (a, b, t) { return a + (b - a) * t; });
RegisterFunction("mix", ["Vector2", "Vector2", "float"], "Vector2", null); // TODO
RegisterFunction("mix", ["Vector3", "Vector3", "float"], "Vector3", null);
RegisterFunction("mix", ["Vector4", "Vector4", "float"], "Vector4", null);
RegisterFunction("mix", ["Color", "Color", "float"], "Color", null);
RegisterFunction("clamp", ["float"], "float", function (a) {
    return Math.max(0, Math.min(1, a));
});
// Vector functions.
RegisterFunction("dot", ["Vector2", "Vector2"], "float", function (a, b) { return a[0] * b[0] + a[1] * b[1]; });
RegisterFunction("dot", ["Vector3", "Vector3"], "float", function (a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; });
RegisterFunction("dot", ["Vector4", "Vector4"], "float", function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
});
RegisterFunction("length", ["Vector2"], "float", function (a) {
    return common_2.Vector2.FromArray(a)
        .normalize()
        .toArray();
});
RegisterFunction("length", ["Vector3"], "float", function (a) {
    return common_2.Vector3.FromArray(a)
        .normalize()
        .toArray();
});
RegisterFunction("length", ["Vector4"], "float", function (a) {
    return common_2.Quaternion.FromArray(a)
        .normalize()
        .toArray();
});
RegisterFunction("length", ["Quaternion"], "float", function (a) {
    return common_2.Quaternion.FromArray(a)
        .normalize()
        .toArray();
});
RegisterFunction("normalize", ["Vector2"], "Vector2", function (a) {
    return common_2.Vector2.FromArray(a).length();
});
RegisterFunction("normalize", ["Vector3"], "Vector3", function (a) {
    return common_2.Vector3.FromArray(a).length();
});
RegisterFunction("normalize", ["Vector4"], "Vector4", function (a) {
    return common_2.Quaternion.FromArray(a).length();
});
RegisterFunction("normalize", ["Quaternion"], "Quaternion", function (a) {
    return common_2.Quaternion.FromArray(a).length();
});
RegisterFunction("cross", ["Vector3", "Vector3"], "Vector3", function (a, b) {
    return common_2.Vector3.FromArray(a)
        .cross(common_2.Vector3.FromArray(b))
        .toArray();
});
// Quaternion functions.
RegisterFunction("quat_mul", ["Quaternion", "Quaternion"], "Quaternion", function (a, b) {
    return common_2.Quaternion.FromArray(a)
        .mul(common_2.Quaternion.FromArray(b))
        .toArray();
});
RegisterFunction("quat_conj", ["Quaternion"], "Quaternion", function (a) {
    return common_2.Quaternion.FromArray(a)
        .conj()
        .toArray();
});
RegisterFunction("quat_slerp", ["Quaternion", "Quaternion", "float"], "Quaternion", function (a, b, t) {
    return common_2.Quaternion.Slerp(common_2.Quaternion.FromArray(a), common_2.Quaternion.FromArray(b), t).toArray();
});
RegisterFunction("quat_rotate", ["Quaternion", "Vector3"], "Vector3", function (q, v) {
    return common_2.Quaternion.FromArray(q)
        .rotate(common_2.Vector3.FromArray(v))
        .toArray();
});
RegisterFunction("quat_rotation", ["Vector3", "float"], "Quaternion", function (axis, angle) {
    return common_2.Quaternion.Rotation(common_2.Vector3.FromArray(axis), angle).toArray();
});
// Color functions.
RegisterConstructor("Color", ["float", "float", "float", "float"], function (r, g, b, a) { return [r, g, b, a]; });
RegisterConstructor("Color", ["float", "float", "float"], function (r, g, b) { return [r, g, b, 1]; });
RegisterConstructor("Color", ["float", "float"], function (v, a) { return [
    v,
    v,
    v,
    a
]; });
RegisterConstructor("Color", ["float"], function (v) { return [v, v, v, 1]; });
RegisterFunction("lab2rgb", ["Color"], "Color", function (color) { return color; });
RegisterFunction("hcl2rgb", ["Color"], "Color", function (color) { return color; });
// Type conversions.
// We only allow low-precision to high-precision conversions to be automated.
RegisterTypeConversion("bool", "int", 1, function (a) { return a; });
RegisterTypeConversion("int", "float", 1, function (a) { return a; });
// Explicit conversions.
RegisterFunction("int", ["float"], "int", function (a) { return Math.floor(a); });
RegisterFunction("float", ["int"], "float", function (a) { return a; });
RegisterTypeConversion("Quaternion", "Vector4", 0, function (a) { return a; });
RegisterTypeConversion("Vector4", "Quaternion", 0, function (a) { return a; });
RegisterTypeConversion("Color", "Vector4", 0, function (a) { return a; });
RegisterTypeConversion("Vector4", "Color", 0, function (a) { return a; });
RegisterTypeConversion("Vector4Array", "ColorArray", 0, function (a) { return a; });
RegisterTypeConversion("ColorArray", "Vector4Array", 0, function (a) { return a; });
RegisterTypeConversion("Vector4Array2D", "Image", 0, function (a) { return a; });
RegisterTypeConversion("Image", "Vector4Image", 0, function (a) { return a; });
// Constants
addConstant("PI", "float", Math.PI);
addConstant("SQRT2", "float", Math.SQRT2);
addConstant("SQRT1_2", "float", Math.SQRT1_2);
addConstant("RED", "Color", [1, 0, 0, 1]);
// Array and image
RegisterFunction("array", ["FloatArray", "float"], "float", not_implemented);
RegisterFunction("array", ["Vector2Array", "float"], "Vector2", not_implemented);
RegisterFunction("array", ["Vector3Array", "float"], "Vector3", not_implemented);
RegisterFunction("array", ["Vector4Array", "float"], "Vector4", not_implemented);
RegisterFunction("array", ["ColorArray", "float"], "Color", not_implemented);
RegisterFunction("image", ["Image", "Vector2"], "Color", not_implemented);
RegisterFunction("image", ["Vector4Image", "Vector2"], "Vector4", not_implemented);
RegisterFunction("image", ["Vector3Image", "Vector2"], "Vector3", not_implemented);
RegisterFunction("image", ["Vector2Image", "Vector2"], "Vector2", not_implemented);
RegisterFunction("image", ["FloatImage", "Vector2"], "float", not_implemented);
// Return the camera position if appliable
RegisterFunction("get_camera_position", [], "Vector3", not_implemented);
// Return a unit vector pointing to the camera
RegisterFunction("get_camera_direction", ["Vector3"], "Vector3", not_implemented);
//# sourceMappingURL=index.js.map