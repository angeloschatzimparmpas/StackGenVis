"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/** Base class for Vector, Quaternion, and Color */
var MathType = /** @class */ (function () {
    function MathType() {
    }
    return MathType;
}());
exports.MathType = MathType;
/** 2D vector */
var Vector2 = /** @class */ (function (_super) {
    __extends(Vector2, _super);
    function Vector2(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.y = y;
        return _this;
    }
    /** Create a Vector2 from a pair of numbers */
    Vector2.FromArray = function (_a) {
        var a = _a[0], b = _a[1];
        return new Vector2(a, b);
    };
    Vector2.prototype.clone = function () {
        return new Vector2(this.x, this.y);
    };
    Vector2.prototype.add = function (rhs) {
        return new Vector2(this.x + rhs.x, this.y + rhs.y);
    };
    Vector2.prototype.sub = function (rhs) {
        return new Vector2(this.x - rhs.x, this.y - rhs.y);
    };
    Vector2.prototype.mul = function (rhs) {
        return new Vector2(this.x * rhs.x, this.y * rhs.y);
    };
    Vector2.prototype.div = function (rhs) {
        return new Vector2(this.x / rhs.x, this.y / rhs.y);
    };
    Vector2.prototype.scale = function (rhs) {
        return new Vector2(this.x * rhs, this.y * rhs);
    };
    Vector2.prototype.dot = function (rhs) {
        return this.x * rhs.x + this.y * rhs.y;
    };
    /** Compute the length of the vector */
    Vector2.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    /** Return the normalized vector. Does not affect this vector */
    Vector2.prototype.normalize = function () {
        var l = Math.sqrt(this.x * this.x + this.y * this.y);
        return new Vector3(this.x / l, this.y / l);
    };
    Vector2.prototype.toArray = function () {
        return [this.x, this.y];
    };
    return Vector2;
}(MathType));
exports.Vector2 = Vector2;
/** 3D vector */
var Vector3 = /** @class */ (function (_super) {
    __extends(Vector3, _super);
    function Vector3(x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.y = y;
        _this.z = z;
        return _this;
    }
    /** Create a Vector3 from a triplet of numbers */
    Vector3.FromArray = function (_a) {
        var a = _a[0], b = _a[1], c = _a[2];
        return new Vector3(a, b, c);
    };
    Vector3.prototype.clone = function () {
        return new Vector3(this.x, this.y, this.z);
    };
    Vector3.prototype.add = function (rhs) {
        return new Vector3(this.x + rhs.x, this.y + rhs.y, this.z + rhs.z);
    };
    Vector3.prototype.sub = function (rhs) {
        return new Vector3(this.x - rhs.x, this.y - rhs.y, this.z - rhs.z);
    };
    Vector3.prototype.mul = function (rhs) {
        return new Vector3(this.x * rhs.x, this.y * rhs.y, this.z * rhs.z);
    };
    Vector3.prototype.div = function (rhs) {
        return new Vector3(this.x / rhs.x, this.y / rhs.y, this.z / rhs.z);
    };
    Vector3.prototype.scale = function (rhs) {
        return new Vector3(this.x * rhs, this.y * rhs, this.z * rhs);
    };
    Vector3.prototype.dot = function (rhs) {
        return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
    };
    Vector3.prototype.cross = function (rhs) {
        return new Vector3(this.y * rhs.z - this.z * rhs.y, this.z * rhs.x - this.x * rhs.z, this.x * rhs.y - this.y * rhs.x);
    };
    /** Compute the length of the vector */
    Vector3.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    /** Return the normalized vector. Does not affect this vector */
    Vector3.prototype.normalize = function () {
        var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        return new Vector3(this.x / l, this.y / l, this.z / l);
    };
    Vector3.prototype.toArray = function () {
        return [this.x, this.y, this.z];
    };
    return Vector3;
}(MathType));
exports.Vector3 = Vector3;
/** Quaternion */
var Quaternion = /** @class */ (function (_super) {
    __extends(Quaternion, _super);
    function Quaternion(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 0; }
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.y = y;
        _this.z = z;
        _this.w = w;
        return _this;
    }
    /** Spherical linear interpolation */
    Quaternion.Slerp = function (q1, q2, t) {
        var acos_arg = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
        if (acos_arg > 1) {
            acos_arg = 1;
        }
        if (acos_arg < -1) {
            acos_arg = -1;
        }
        var omega = Math.acos(acos_arg);
        var st0, st1;
        if (Math.abs(omega) < 1e-10) {
            st0 = 1 - t;
            st1 = t;
        }
        else {
            var som = Math.sin(omega);
            st0 = Math.sin((1 - t) * omega) / som;
            st1 = Math.sin(t * omega) / som;
        }
        return new Quaternion(q1.x * st0 + q2.x * st1, q1.y * st0 + q2.y * st1, q1.z * st0 + q2.z * st1, q1.w * st0 + q2.w * st1);
    };
    /** Create a rotation quaternion from axis and rotation angle */
    Quaternion.Rotation = function (axis, angle) {
        var axis_normal = axis.normalize().scale(Math.sin(angle / 2));
        return new Quaternion(axis_normal.x, axis_normal.y, axis_normal.z, Math.cos(angle / 2));
    };
    /** Create a Vector2 from an array of four numbers */
    Quaternion.FromArray = function (_a) {
        var a = _a[0], b = _a[1], c = _a[2], d = _a[3];
        return new Quaternion(a, b, c, d);
    };
    Quaternion.prototype.clone = function () {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };
    /** Return the conjugate of this quaternion */
    Quaternion.prototype.conj = function () {
        return new Quaternion(-this.x, -this.y, -this.z, this.w);
    };
    /** Quaternion multiplication */
    Quaternion.prototype.mul = function (rhs) {
        return new Quaternion(rhs.x * this.w + this.x * rhs.w + this.y * rhs.z - this.z * rhs.y, rhs.y * this.w + this.y * rhs.w + this.z * rhs.x - this.x * rhs.z, rhs.z * this.w + this.z * rhs.w + this.x * rhs.y - this.y * rhs.x, this.w * rhs.w - this.x * rhs.x - this.y * rhs.y - this.z * rhs.z);
    };
    /** Rotate the vector with this quaternion */
    Quaternion.prototype.rotate = function (vector) {
        var q = new Quaternion(vector.x, vector.y, vector.z, 0);
        var qv = this.mul(q).mul(this.conj());
        return new Vector3(qv.x, qv.y, qv.z);
    };
    /** Compute the length of the quaternion */
    Quaternion.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    };
    /** Return the normalized quaternion. Does not affect this quaternion */
    Quaternion.prototype.normalize = function () {
        var s = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        return new Quaternion(this.x / s, this.y / s, this.z / s, this.w / s);
    };
    /** Spherical linear interpolation */
    Quaternion.prototype.slerp = function (rhs, t) {
        return Quaternion.Slerp(this, rhs, t);
    };
    Quaternion.prototype.toArray = function () {
        return [this.x, this.y, this.z, this.w];
    };
    return Quaternion;
}(MathType));
exports.Quaternion = Quaternion;
/** 3D pose */
var Pose = /** @class */ (function () {
    function Pose(position, rotation) {
        if (position === void 0) { position = new Vector3(0, 0, 0); }
        if (rotation === void 0) { rotation = new Quaternion(0, 0, 0, 1); }
        this.position = position;
        this.rotation = rotation;
    }
    Pose.prototype.transform = function (point) {
        return this.rotation.rotate(point).add(this.position);
    };
    Pose.prototype.transformDirection = function (direction) {
        return this.rotation.rotate(direction);
    };
    Pose.prototype.concat = function (pose2) {
        return new Pose(this.rotation.rotate(pose2.position).add(this.position), this.rotation.mul(pose2.rotation));
    };
    Pose.prototype.invert = function () {
        var invRotation = this.rotation.conj();
        return new Pose(invRotation.rotate(this.position).scale(-1), invRotation);
    };
    return Pose;
}());
exports.Pose = Pose;
//# sourceMappingURL=math.js.map