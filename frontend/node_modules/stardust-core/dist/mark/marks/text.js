"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var mark_1 = require("../mark");
var binding_1 = require("../../binding");
var compile_1 = require("../compile");
var TextCache = require("./textCache");
var TextMark = /** @class */ (function (_super) {
    __extends(TextMark, _super);
    function TextMark(mode, platform) {
        if (mode === void 0) { mode = "2d"; }
        var _this = _super.call(this, compile_1.compile("\n        mark TextMark(\n          position: " + (mode == "2d" ? "Vector2" : "Vector3") + ",\n          normal: Vector3 = [ 0, 0, 1 ],\n          up: " + (mode == "2d" ? "Vector2 = [ 0, 1 ]" : "Vector3 = [ 0, 1, 0 ]") + ",\n          scale: float = 1,\n          color: Color = [ 0, 0, 0, 1 ],\n          alignX: float = 0,\n          alignY: float = 0,\n          mScaling: float,\n          mImage: Image,\n          mTextInfo: Vector4Array,\n          mIndex: float\n        ) {\n          let p = " + (mode == "2d" ? "Vector3(position.x, position.y, 0)" : "position") + ";\n          let info = array(mTextInfo, mIndex);\n          let e1 = normalize(cross(" + (mode == "2d" ? "Vector3(up.x, up.y, 0)" : "up") + ", normal)) * info.x * (scale / mScaling);\n          let e2 = normalize(cross(normal, e1)) * info.y * (scale / mScaling);\n          p = p - e1 * alignX - e2 * (1 - alignY);\n          let mSizeX = Vector2(info.x, 0);\n          let mSizeY = Vector2(0, info.y);\n          let mTexPos = Vector2(info.z, info.w);\n          emit [\n              { position: p, tp: mTexPos, color: color },\n              { position: p + e1, tp: mTexPos + mSizeX, color: color },\n              { position: p + e1 + e2, tp: mTexPos + mSizeX + mSizeY, color: color },\n              { position: p, tp: mTexPos, color: color },\n              { position: p + e1 + e2, tp: mTexPos + mSizeX + mSizeY, color: color },\n              { position: p + e2, tp: mTexPos + mSizeY, color: color }\n          ];\n        }\n      ").TextMark, compile_1.compile("\n        shader TextShader(\n          tp: Vector2,\n          mImage: Image,\n          color: Color\n        ) {\n          let c = image(mImage, tp);\n          let alpha = c.a;\n          if(alpha == 0) {\n            discard;\n          } else {\n            emit { color: Color(color.r, color.g, color.b, alpha * color.a) };\n          }\n        }\n      ").TextShader, platform) || this;
        _this._textBinding = "text";
        _this._fontFamilyBinding = "Arial";
        _this._fontSizeBinding = 12;
        _this._fontWeightBinding = "normal";
        _this._fontStyleBinding = "normal";
        _this._textCache = new TextCache.TextCache(1024, 1024);
        _this._image = new binding_1.Image();
        _this._textInfo = new binding_1.ArrayBinding();
        _this.attr("mScaling", _this._textCache.scaling);
        _this.attr("mImage", _this._image);
        _this.attr("mIndex", function (d, i) { return i; });
        _this.attr("mTextInfo", _this._textInfo);
        _this._shouldRefreshCanvas = true;
        return _this;
    }
    TextMark.prototype.prepare = function () {
        var _this = this;
        if (this._shouldRefreshCanvas) {
            var data = this.data();
            var texts_1 = new binding_1.Binding("string", this._textBinding).map(data);
            var fontFamilys_1 = new binding_1.Binding("string", this._fontFamilyBinding).map(data);
            var fontSizes_1 = new binding_1.Binding("string", this._fontSizeBinding).map(data);
            var fontWeights_1 = new binding_1.Binding("string", this._fontWeightBinding).map(data);
            var fontStyles_1 = new binding_1.Binding("string", this._fontStyleBinding).map(data);
            var attempt = function () {
                _this._textLayouts = texts_1.map(function (x, i) {
                    var font = new TextCache.Font(fontFamilys_1[i].toString(), fontSizes_1[i], fontWeights_1[i].toString(), fontStyles_1[i].toString());
                    var info = _this._textCache.addText(x.toString(), font);
                    return {
                        size: [info.w, info.h],
                        position: [info.x, info.y]
                    };
                });
            };
            try {
                attempt();
            }
            catch (e) {
                this._textCache.clear();
                attempt();
            }
            this._textInfo.data(texts_1);
            this._textInfo.value(function (d, i) { return [
                _this._textLayouts[i].size[0],
                _this._textLayouts[i].size[1],
                _this._textLayouts[i].position[0],
                _this._textLayouts[i].position[1]
            ]; });
            this.attr("mTextInfo", this._textInfo);
            if (this._textCache.updated) {
                this._image.setImage(this._textCache.canvas);
                this.attr("mImage", this._image);
                this._textCache.updated = false;
            }
            this._shouldRefreshCanvas = false;
        }
        return _super.prototype.prepare.call(this);
    };
    TextMark.prototype.attr = function (name, value) {
        switch (name) {
            case "text": {
                if (value === undefined) {
                    return this._textBinding;
                }
                else {
                    this._textBinding = value;
                    this._shouldRefreshCanvas = true;
                    return this;
                }
            }
            case "fontFamily": {
                if (value === undefined) {
                    return this._fontFamilyBinding;
                }
                else {
                    this._fontFamilyBinding = value;
                    this._shouldRefreshCanvas = true;
                    return this;
                }
            }
            case "fontSize": {
                if (value === undefined) {
                    return this._fontSizeBinding;
                }
                else {
                    this._fontSizeBinding = value;
                    this._shouldRefreshCanvas = true;
                    return this;
                }
            }
            case "fontWeight": {
                if (value === undefined) {
                    return this._fontWeightBinding;
                }
                else {
                    this._fontWeightBinding = value;
                    this._shouldRefreshCanvas = true;
                    return this;
                }
            }
            case "fontStyle": {
                if (value === undefined) {
                    return this._fontStyleBinding;
                }
                else {
                    this._fontStyleBinding = value;
                    this._shouldRefreshCanvas = true;
                    return this;
                }
            }
            default: {
                return _super.prototype.attr.call(this, name, value);
            }
        }
    };
    TextMark.prototype.data = function (data) {
        if (data === undefined) {
            return _super.prototype.data.call(this);
        }
        else {
            _super.prototype.data.call(this, data);
            this._shouldRefreshCanvas = true;
            return this;
        }
    };
    return TextMark;
}(mark_1.Mark));
exports.TextMark = TextMark;
function createText(mode, platform) {
    return new TextMark(mode, platform);
}
exports.createText = createText;
//# sourceMappingURL=text.js.map