"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("../common");
var common_2 = require("../common");
var Intrinsics = require("../intrinsics");
var ModuleResolver = /** @class */ (function () {
    function ModuleResolver() {
        var _this = this;
        this._functions = new common_2.Dictionary();
        this._functionModule = new common_2.Dictionary();
        this._currentMoudles = [];
        Intrinsics.forEachIntrinsicFunction(function (info) {
            _this.addIntrinsicFunction(info.name, {
                type: "function",
                isMark: false,
                isShader: false,
                name: info.internalName,
                returnType: info.returnType,
                arguments: info.argTypes.map(function (x, idx) { return ({
                    name: "a" + idx,
                    type: x
                }); }),
                statements: null
            });
        });
    }
    ModuleResolver.prototype.addIntrinsicFunction = function (name, func) {
        if (!this._functions.has(name)) {
            var resolver = new FunctionOverloadResolver(name);
            this._functions.set(name, resolver);
            resolver.addFunction(func);
        }
        else {
            var resolver = this._functions.get(name);
            resolver.addFunction(func);
        }
    };
    ModuleResolver.prototype.addFunction = function (name, func) {
        if (!this._functions.has(name)) {
            var resolver = new FunctionOverloadResolver(name);
            this._functions.set(name, resolver);
            resolver.addFunction(func);
        }
        else {
            var resolver = this._functions.get(name);
            resolver.addFunction(func);
        }
    };
    ModuleResolver.prototype.importFunction = function (module, name) {
        this.addFunction(name, module.get(name));
        this._functionModule.set(name, module);
    };
    ModuleResolver.prototype.getFunction = function (name) {
        for (var i = this._currentMoudles.length - 1; i >= 0; i--) {
            var cm = this._currentMoudles[i];
            if (cm && cm.has(name)) {
                var resolver = new FunctionOverloadResolver(name);
                resolver.addFunction(cm.get(name));
                return resolver;
            }
        }
        if (this._functions.has(name)) {
            return this._functions.get(name);
        }
        else {
            return null;
        }
    };
    ModuleResolver.prototype.enterFunctionImplementation = function (name) {
        this._currentMoudles.push(this._functionModule.get(name));
    };
    ModuleResolver.prototype.leaveFunctionImplementation = function (name) {
        this._currentMoudles.pop();
    };
    return ModuleResolver;
}());
exports.ModuleResolver = ModuleResolver;
var FunctionOverloadResolver = /** @class */ (function () {
    function FunctionOverloadResolver(name) {
        this._name = name;
        this._functions = [];
    }
    FunctionOverloadResolver.prototype.addFunction = function (func) {
        this._functions.push(func);
    };
    FunctionOverloadResolver.prototype.resolveArguments = function (args, kwargs) {
        var result = null;
        var resultRank = null;
        for (var _i = 0, _a = this._functions; _i < _a.length; _i++) {
            var func = _a[_i];
            var funcRank = 0;
            var matched = true;
            var argExpressions = [];
            var argIndexUsed = [];
            var kwargsUsed = [];
            for (var argIndex in func.arguments) {
                var arg = func.arguments[argIndex];
                var argExpression = args[argIndex] || kwargs[arg.name];
                if (args[argIndex] != null) {
                    argIndexUsed.push(argIndex);
                }
                else if (kwargs[arg.name]) {
                    kwargsUsed.push(arg.name);
                }
                if (argExpression != null) {
                    if (argExpression.valueType != arg.type) {
                        var _b = typeConversionAttempt(argExpression, arg.type), conversion = _b[0], rank = _b[1];
                        if (conversion) {
                            argExpressions.push(conversion);
                            funcRank += rank;
                        }
                        else {
                            matched = false;
                            break;
                        }
                    }
                    else {
                        argExpressions.push(argExpression);
                    }
                }
                else {
                    if (arg.default === null || arg.default === undefined) {
                        matched = false;
                        break;
                    }
                    else {
                        argExpressions.push({
                            type: "constant",
                            value: arg.default,
                            valueType: arg.type
                        });
                    }
                }
            }
            var isAllUsed = true;
            for (var argIndex in args) {
                if (argIndexUsed.indexOf(argIndex) < 0) {
                    isAllUsed = false;
                }
            }
            for (var argName in kwargs) {
                if (kwargsUsed.indexOf(argName) < 0) {
                    isAllUsed = false;
                }
            }
            if (matched && isAllUsed) {
                if (!result || funcRank < resultRank) {
                    result = [func, argExpressions];
                    resultRank = funcRank;
                }
            }
        }
        if (result) {
            return result;
        }
        else {
            var argspec = args.map(function (x) { return x.valueType; }).join(", ");
            throw new common_1.CompileError("unable to resolve function '" + this._name + "' with arguments (" + argspec + ")");
        }
    };
    return FunctionOverloadResolver;
}());
exports.FunctionOverloadResolver = FunctionOverloadResolver;
function typeConversionAttempt(src, dest) {
    var info = Intrinsics.getTypeConversion(src.valueType, dest);
    if (info) {
        var rank = info.rank;
        return [
            {
                type: "function",
                valueType: dest,
                arguments: [src],
                functionName: info.internalName
            },
            rank
        ];
    }
    else {
        return [null, null];
    }
}
exports.typeConversionAttempt = typeConversionAttempt;
//# sourceMappingURL=resolver.js.map