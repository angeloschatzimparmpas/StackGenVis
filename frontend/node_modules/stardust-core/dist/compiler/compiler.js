"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("../common");
var common_2 = require("../common");
var Intrinsics = require("../intrinsics");
var Library = require("../library");
var parser_1 = require("./parser");
var resolver_1 = require("./resolver");
var scope_1 = require("./scope");
var Compiler = /** @class */ (function () {
    function Compiler() {
        this._scope = new scope_1.ScopeStack();
        this._constants = new common_2.Dictionary();
        this._moduleResolver = new resolver_1.ModuleResolver();
        this._statements = [];
        this._lastIndex = 1;
        this.prepareFieldTypeRegistry();
        this.prepareConstants();
    }
    Compiler.prototype.prepareFieldTypeRegistry = function () {
        this._fieldTypeRegistry = {};
        var r = this._fieldTypeRegistry;
        for (var _i = 0, _a = ["x", "y"]; _i < _a.length; _i++) {
            var f = _a[_i];
            r["Vector2." + f] = "float";
        }
        for (var _b = 0, _c = ["x", "y", "z", "r", "g", "b"]; _b < _c.length; _b++) {
            var f = _c[_b];
            r["Vector3." + f] = "float";
        }
        for (var _d = 0, _e = ["x", "y", "z", "w", "r", "g", "b", "a"]; _d < _e.length; _d++) {
            var f = _e[_d];
            r["Vector4." + f] = "float";
        }
        for (var _f = 0, _g = ["r", "g", "b", "a"]; _f < _g.length; _f++) {
            var f = _g[_f];
            r["Color." + f] = "float";
        }
    };
    Compiler.prototype.prepareConstants = function () {
        var _this = this;
        Intrinsics.forEachConstant(function (info) {
            _this._constants.set(info.name, info);
        });
    };
    Compiler.prototype.resolveFunction = function (name, args, kwargs) {
        var resolver = this._moduleResolver.getFunction(name);
        if (resolver) {
            return resolver.resolveArguments(args, kwargs);
        }
        else {
            throw new common_1.CompileError("function '" + name + " is undefined.");
        }
    };
    Compiler.prototype.loadFile = function (file) {
        var _this = this;
        var _loop_1 = function (block) {
            if (block.type == "function") {
                var blockFunction = block;
                this_1._moduleResolver.addFunction(blockFunction.name, blockFunction);
            }
            if (block.type == "import") {
                var blockImport_1 = block;
                if (blockImport_1.functionNames != null) {
                    blockImport_1.functionNames.forEach(function (name) {
                        _this._moduleResolver.importFunction(Library.getModule(blockImport_1.moduleName), name);
                    });
                }
                else {
                    var module_1 = Library.getModule(blockImport_1.moduleName);
                    module_1.forEach(function (func, name) {
                        _this._moduleResolver.importFunction(module_1, name);
                    });
                }
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {
            var block = _a[_i];
            _loop_1(block);
        }
    };
    Compiler.prototype.getDefaultValueForType = function (type) {
        if (type == "float") {
            return 0;
        }
        if (type == "Vector2") {
            return [0, 0];
        }
        if (type == "Vector3") {
            return [0, 0, 0];
        }
        if (type == "Vector4") {
            return [0, 0, 0, 0];
        }
        if (type == "Color") {
            return [0, 0, 0, 1];
        }
        if (type == "Quaternion") {
            return [0, 0, 0, 1];
        }
        return 0;
    };
    Compiler.prototype.compileFunctionToMark = function (globals, block) {
        // Re-init state.
        this._scope.resetScope();
        this._lastIndex = 1;
        var markInput = {};
        var markOutput = {};
        var markVariables = {};
        // Setup input parameters.
        for (var _i = 0, globals_1 = globals; _i < globals_1.length; _i++) {
            var global_1 = globals_1[_i];
            this._scope.addVariable(global_1.name, global_1.valueType, "global");
            markInput[global_1.name] = {
                type: global_1.valueType,
                default: global_1.default || this.getDefaultValueForType(global_1.valueType)
            };
        }
        for (var _a = 0, _b = block.arguments; _a < _b.length; _a++) {
            var arg = _b[_a];
            this._scope.addVariable(arg.name, arg.type, "local");
            markInput[arg.name] = {
                type: arg.type,
                default: arg.default || this.getDefaultValueForType(arg.type)
            };
        }
        // Flatten statements.
        this.compileStatements({
            type: "statements",
            statements: block.statements
        });
        // Figure out variables.
        this._scope.forEach(function (name, type) {
            if (!markInput[name]) {
                markVariables[name] = type;
            }
        });
        // Figure out outputs.
        var processStatementsForOutputs = function (statements) {
            statements.forEach(function (x) {
                if (x.type == "emit") {
                    var sEmit = x;
                    for (var attr in sEmit.attributes) {
                        if (markOutput.hasOwnProperty(attr)) {
                            if (markOutput[attr].type != sEmit.attributes[attr].valueType) {
                                throw new common_1.CompileError("output variable '" + attr + " has conflicting types.");
                            }
                        }
                        else {
                            markOutput[attr] = { type: sEmit.attributes[attr].valueType };
                        }
                    }
                }
                if (x.type == "condition") {
                    var sCondition = x;
                    processStatementsForOutputs(sCondition.trueStatements);
                    processStatementsForOutputs(sCondition.falseStatements);
                }
                if (x.type == "for") {
                    var sForLoop = x;
                    processStatementsForOutputs(sForLoop.statements);
                }
            });
        };
        processStatementsForOutputs(this._statements);
        return {
            input: markInput,
            output: markOutput,
            variables: markVariables,
            statements: this._statements
        };
    };
    Compiler.prototype.addStatement = function (statement) {
        this._statements.push(statement);
    };
    Compiler.prototype.addStatements = function (statements) {
        this._statements = this._statements.concat(statements);
    };
    Compiler.prototype.captureStatements = function (callback) {
        var currentStatements = this._statements;
        this._statements = [];
        callback();
        var result = this._statements;
        this._statements = currentStatements;
        return result;
    };
    Compiler.prototype.compileExpression = function (expression) {
        switch (expression.type) {
            case "value": {
                var expr = expression;
                return {
                    type: "constant",
                    value: expr.value,
                    valueType: expr.valueType
                };
            }
            case "variable": {
                var expr = expression;
                if (this._constants.has(expr.name)) {
                    var cinfo = this._constants.get(expr.name);
                    return {
                        type: "constant",
                        value: cinfo.value,
                        valueType: cinfo.type
                    };
                }
                else {
                    return {
                        type: "variable",
                        variableName: this._scope.translateVariableName(expr.name),
                        valueType: this._scope.getVariable(expr.name).type
                    };
                }
            }
            case "field": {
                var expr = expression;
                var valueExpr = this.compileExpression(expr.value);
                return {
                    type: "field",
                    fieldName: expr.fieldName,
                    value: valueExpr,
                    valueType: this._fieldTypeRegistry[valueExpr.valueType + "." + expr.fieldName]
                };
            }
            case "function": {
                var expr = expression;
                var args = [];
                var kwargs = {};
                for (var _i = 0, _a = expr.args.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    args.push(this.compileExpression(arg));
                }
                for (var key in expr.args.kwargs) {
                    var e = expr.args.kwargs[key];
                    kwargs[key] = this.compileExpression(expr.args.kwargs[key]);
                }
                var _b = this.resolveFunction(expr.name, args, kwargs), func = _b[0], argExpressions = _b[1];
                var returnValueExpression = null;
                if (!func.statements) {
                    returnValueExpression = {
                        type: "function",
                        functionName: func.name,
                        arguments: argExpressions,
                        valueType: func.returnType
                    };
                }
                else {
                    var argMap = new common_2.Dictionary();
                    for (var argIndex in func.arguments) {
                        var arg = func.arguments[argIndex];
                        var mapped = this._scope.nextVariableName(arg.type);
                        argMap.set(arg.name, mapped);
                        this.addStatement({
                            type: "assign",
                            variableName: this._scope.translateVariableName(mapped),
                            expression: argExpressions[argIndex]
                        });
                    }
                    this._scope.pushScope(argMap);
                    this._moduleResolver.enterFunctionImplementation(expr.name);
                    for (var _c = 0, _d = func.statements; _c < _d.length; _c++) {
                        var statement = _d[_c];
                        if (statement.type == "return") {
                            var statement_return = statement;
                            returnValueExpression = this.compileExpression(statement_return.value);
                            break;
                        }
                        else {
                            this.compileStatement(statement);
                        }
                    }
                    this._moduleResolver.leaveFunctionImplementation(expr.name);
                    this._scope.popScope();
                }
                return returnValueExpression;
            }
        }
        return null;
    };
    Compiler.prototype.compileStandaloneExpression = function (expression, variables) {
        switch (expression.type) {
            case "value": {
                var expr = expression;
                return {
                    type: "constant",
                    value: expr.value,
                    valueType: expr.valueType
                };
            }
            case "variable": {
                var expr = expression;
                if (variables.has(expr.name)) {
                    return variables.get(expr.name);
                }
                else {
                    if (this._constants.has(expr.name)) {
                        var cinfo = this._constants.get(expr.name);
                        return {
                            type: "constant",
                            value: cinfo.value,
                            valueType: cinfo.type
                        };
                    }
                    else {
                        throw new common_1.CompileError("variable " + expr.name + " is undefined");
                    }
                }
            }
            case "field": {
                var expr = expression;
                var valueExpr = this.compileStandaloneExpression(expr.value, variables);
                return {
                    type: "field",
                    fieldName: expr.fieldName,
                    value: valueExpr,
                    valueType: this._fieldTypeRegistry[valueExpr.valueType + "." + expr.fieldName]
                };
            }
            case "function": {
                var expr = expression;
                var args = [];
                var kwargs = {};
                for (var _i = 0, _a = expr.args.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    args.push(this.compileStandaloneExpression(arg, variables));
                }
                for (var key in expr.args.kwargs) {
                    var e = expr.args.kwargs[key];
                    kwargs[key] = this.compileStandaloneExpression(expr.args.kwargs[key], variables);
                }
                var _b = this.resolveFunction(expr.name, args, kwargs), func = _b[0], argExpressions = _b[1];
                return {
                    type: "function",
                    functionName: func.name,
                    arguments: argExpressions,
                    valueType: func.returnType
                };
            }
        }
        return null;
    };
    Compiler.prototype.compileStatements = function (statements) {
        this._scope.pushScope();
        for (var _i = 0, _a = statements.statements; _i < _a.length; _i++) {
            var s = _a[_i];
            this.compileStatement(s);
        }
        this._scope.popScope();
    };
    Compiler.prototype.compileStatement = function (statement) {
        var _this = this;
        switch (statement.type) {
            case "declare":
                {
                    var s = statement;
                    if (s.initial) {
                        var ve = this.compileExpression(s.initial);
                        var variableType = s.variableType;
                        if (variableType == "auto") {
                            variableType = ve.valueType;
                        }
                        this._scope.addVariable(s.variableName, variableType, "local");
                        if (ve.valueType != variableType) {
                            var veType = ve.valueType;
                            ve = resolver_1.typeConversionAttempt(ve, this._scope.getVariable(s.variableName).type)[0];
                            if (ve === null) {
                                throw new common_1.CompileError("cannot convert type '" + veType + "' to '" + variableType + "'.");
                            }
                        }
                        this.addStatement({
                            type: "assign",
                            variableName: this._scope.translateVariableName(s.variableName),
                            expression: ve
                        });
                    }
                    else {
                        this._scope.addVariable(s.variableName, s.variableType, "local");
                    }
                }
                break;
            case "expression":
                {
                    var s = statement;
                    this.compileExpression(s.expression);
                }
                break;
            case "assign":
                {
                    var s = statement;
                    var ve = this.compileExpression(s.expression);
                    var targetType = this._scope.getVariable(s.variableName).type;
                    if (ve.valueType != targetType) {
                        var veType = ve.valueType;
                        ve = resolver_1.typeConversionAttempt(ve, this._scope.getVariable(s.variableName).type)[0];
                        if (ve === null) {
                            throw new common_1.CompileError("cannot convert type '" + veType + " to '" + targetType + "'.");
                        }
                    }
                    this.addStatement({
                        type: "assign",
                        variableName: this._scope.translateVariableName(s.variableName),
                        expression: ve
                    });
                }
                break;
            case "emit":
                {
                    var s = statement;
                    s.vertices.forEach(function (v) {
                        var attrs = {};
                        for (var argName in v) {
                            var expr = v[argName];
                            attrs[argName] = _this.compileExpression(expr);
                        }
                        _this.addStatement({
                            type: "emit",
                            attributes: attrs
                        });
                    });
                }
                break;
            case "discard":
                {
                    this.addStatement({
                        type: "discard"
                    });
                }
                break;
            case "statements":
                {
                    var s = statement;
                    this.compileStatements(s);
                }
                break;
            case "for":
                {
                    var s_1 = statement;
                    this._scope.pushScope();
                    // Declare the loop variable
                    this._scope.addVariable(s_1.variableName, "int", "local");
                    var loopVariable = this._scope.translateVariableName(s_1.variableName);
                    // Compile for statements
                    var forStatement = {
                        type: "for",
                        variableName: loopVariable,
                        rangeMin: s_1.start,
                        rangeMax: s_1.end,
                        statements: this.captureStatements(function () {
                            return _this.compileStatement(s_1.statement);
                        })
                    };
                    this.addStatement(forStatement);
                    this._scope.popScope();
                }
                break;
            case "if":
                {
                    var s_2 = statement;
                    // Function to compile the i-th condition in the if-elseif-else syntax.
                    var compileIthCondition_1 = function (i) {
                        if (i < s_2.conditions.length) {
                            var statements = [];
                            _this._scope.pushScope();
                            var ve = _this.compileExpression(s_2.conditions[i].condition);
                            var cond = {
                                type: "condition",
                                condition: ve,
                                trueStatements: _this.captureStatements(function () {
                                    return _this.compileStatement(s_2.conditions[i].statement);
                                }),
                                falseStatements: _this.captureStatements(function () {
                                    return compileIthCondition_1(i + 1);
                                })
                            };
                            _this.addStatement(cond);
                            _this._scope.popScope();
                        }
                        else {
                            if (s_2.else) {
                                _this.compileStatement(s_2.else);
                            }
                        }
                    };
                    compileIthCondition_1(0);
                }
                break;
            case "return": {
                throw new common_1.CompileError("unexpected return statement");
            }
        }
    };
    return Compiler;
}());
exports.Compiler = Compiler;
function compileTree(file) {
    var spec = {};
    var globals = file.blocks.filter(function (x) { return x.type == "global"; });
    for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {
        var block = _a[_i];
        if (block.type == "function") {
            var blockFunction = block;
            if (blockFunction.isMark || blockFunction.isShader) {
                var scope = new Compiler();
                scope.loadFile(file);
                var mark = scope.compileFunctionToMark(globals, blockFunction);
                spec[blockFunction.name] = mark;
            }
        }
    }
    return spec;
}
exports.compileTree = compileTree;
var standaloneCompiler = new Compiler();
function compileExpression(expr, variables) {
    return standaloneCompiler.compileStandaloneExpression(expr, variables);
}
exports.compileExpression = compileExpression;
function compileString(content) {
    var file = parser_1.parseFile(content);
    return compileTree(file);
}
exports.compileString = compileString;
//# sourceMappingURL=compiler.js.map