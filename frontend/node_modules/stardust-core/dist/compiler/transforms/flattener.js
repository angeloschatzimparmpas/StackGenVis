"use strict";
// Flattener: Resolve emit statements into individual render calls.
Object.defineProperty(exports, "__esModule", { value: true });
var Specification = require("../../specification");
var SC = Specification.Construct;
var common_1 = require("../../common");
// For now, assume there is no conditional emits.
function flattenEmits(mark) {
    var vertexIndexNameFloat = common_1.attemptName("s3idx", function (c) { return !mark.variables.hasOwnProperty(c) && !mark.input.hasOwnProperty(c); });
    var vertexIndexName = common_1.attemptName("s3idx_i", function (c) { return !mark.variables.hasOwnProperty(c) && !mark.input.hasOwnProperty(c); });
    var emitIndexName = common_1.attemptName("s3emitidx", function (c) { return !mark.variables.hasOwnProperty(c) && !mark.input.hasOwnProperty(c); });
    var newMark = {
        input: {},
        output: mark.output,
        variables: mark.variables,
        statements: [],
        repeatBegin: mark.repeatBegin,
        repeatEnd: mark.repeatEnd
    };
    for (var i in mark.input) {
        if (mark.input.hasOwnProperty(i)) {
            newMark.input[i] = mark.input[i];
        }
    }
    newMark.input[vertexIndexNameFloat] = {
        type: "float",
        default: 0
    };
    newMark.variables[vertexIndexName] = "int";
    newMark.variables[emitIndexName] = "int";
    newMark.statements.push({
        type: "assign",
        variableName: vertexIndexName,
        expression: SC.cast(SC.variable(vertexIndexNameFloat, "float"), "int")
    });
    newMark.statements.push({
        type: "assign",
        variableName: emitIndexName,
        expression: SC.constant(0, "int")
    });
    var generateStatements = function (statements) {
        var result = [];
        var maxNumberEmits = 0;
        for (var i = 0; i < statements.length; i++) {
            switch (statements[i].type) {
                case "emit":
                    {
                        result.push({
                            type: "condition",
                            condition: SC.equals(SC.variable(vertexIndexName, "int"), SC.variable(emitIndexName, "int")),
                            trueStatements: [statements[i]],
                            falseStatements: []
                        });
                        result.push({
                            type: "assign",
                            variableName: emitIndexName,
                            expression: SC.add(SC.variable(emitIndexName, "int"), SC.constant(1, "int"))
                        });
                        maxNumberEmits += 1;
                    }
                    break;
                case "for":
                    {
                        var forStatement = statements[i];
                        var _a = generateStatements(forStatement.statements), generatedStatements_1 = _a[0], maxNumber = _a[1];
                        var mappingMode = true;
                        if (mappingMode) {
                            // Here we assume for loops only alter its internal variables, not anything outside, so each turn is independent.
                            var tStatements = [];
                            tStatements.push({
                                type: "assign",
                                variableName: forStatement.variableName,
                                expression: SC.add(SC.div(SC.sub(SC.variable(vertexIndexName, "int"), SC.variable(emitIndexName, "int")), SC.constant(maxNumber, "int")), SC.constant(forStatement.rangeMin, "int"))
                            });
                            tStatements.push({
                                type: "assign",
                                variableName: emitIndexName,
                                expression: SC.add(SC.variable(emitIndexName, "int"), SC.mul(SC.constant(maxNumber, "int"), SC.sub(SC.variable(forStatement.variableName, "int"), SC.constant(forStatement.rangeMin, "int"))))
                            });
                            tStatements = tStatements.concat(generatedStatements_1);
                            tStatements.push({
                                type: "assign",
                                variableName: emitIndexName,
                                expression: SC.add(SC.variable(emitIndexName, "int"), SC.mul(SC.constant(maxNumber, "int"), SC.sub(SC.constant(forStatement.rangeMax, "int"), SC.variable(forStatement.variableName, "int"))))
                            });
                            result.push({
                                type: "condition",
                                condition: SC.op("&&", "bool", SC.greaterThanOrEquals(SC.variable(vertexIndexName, "int"), SC.variable(emitIndexName, "int")), SC.lessThan(SC.variable(vertexIndexName, "int"), SC.add(SC.variable(emitIndexName, "int"), SC.constant(maxNumber *
                                    (forStatement.rangeMax - forStatement.rangeMin + 1), "int")))),
                                trueStatements: tStatements,
                                falseStatements: [
                                    {
                                        type: "assign",
                                        variableName: emitIndexName,
                                        expression: SC.add(SC.variable(emitIndexName, "int"), SC.constant((forStatement.rangeMax - forStatement.rangeMin + 1) *
                                            maxNumber, "int"))
                                    }
                                ]
                            });
                        }
                        else {
                            result.push({
                                type: "for",
                                variableName: forStatement.variableName,
                                rangeMin: forStatement.rangeMin,
                                rangeMax: forStatement.rangeMax,
                                statements: generatedStatements_1
                            });
                        }
                        maxNumberEmits +=
                            (forStatement.rangeMax - forStatement.rangeMin + 1) * maxNumber;
                    }
                    break;
                case "condition":
                    {
                        var condStatement = statements[i];
                        var _b = generateStatements(condStatement.trueStatements), gTrueStatements = _b[0], gTrueStatementsMax = _b[1];
                        var _c = generateStatements(condStatement.falseStatements), gFalseStatements = _c[0], gFalseStatementsMax = _c[1];
                        result.push({
                            type: "condition",
                            condition: condStatement.condition,
                            trueStatements: gTrueStatements,
                            falseStatements: gFalseStatements
                        });
                        maxNumberEmits = Math.max(gTrueStatementsMax, gFalseStatementsMax);
                    }
                    break;
                default:
                    {
                        result.push(statements[i]);
                    }
                    break;
            }
        }
        return [result, maxNumberEmits];
    };
    var _a = generateStatements(mark.statements), generatedStatements = _a[0], maxNumberEmits = _a[1];
    newMark.statements = newMark.statements.concat(generatedStatements);
    return {
        specification: newMark,
        count: maxNumberEmits,
        indexVariable: vertexIndexNameFloat
    };
}
exports.flattenEmits = flattenEmits;
//# sourceMappingURL=flattener.js.map