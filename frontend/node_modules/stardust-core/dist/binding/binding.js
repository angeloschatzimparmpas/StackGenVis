"use strict";
// binding.js:
// Take care of data binding.
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var array_1 = require("./array");
var common_1 = require("../common");
var types_1 = require("./types");
__export(require("./types"));
__export(require("./array"));
// The main binding class.
var Binding = /** @class */ (function () {
    function Binding(typeName, value) {
        this._type = types_1.types[typeName];
        this._value = value;
    }
    Object.defineProperty(Binding.prototype, "valueType", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "bindingType", {
        get: function () {
            if (this._value instanceof array_1.TextureBinding) {
                return types_1.BindingType.TEXTURE;
            }
            if (typeof this._value == "function") {
                return types_1.BindingType.FUNCTION;
            }
            return types_1.BindingType.VALUE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "specValue", {
        get: function () {
            return types_1.getBindingValue(this._value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Binding.prototype, "textureValue", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Binding.prototype.forEach = function (data, callback) {
        switch (this.bindingType) {
            case types_1.BindingType.FUNCTION:
                {
                    var f = this._value;
                    for (var i = 0; i < data.length; i++) {
                        callback(types_1.getBindingValue(f(data[i], i)), i);
                    }
                }
                break;
            case types_1.BindingType.VALUE:
                {
                    var value = types_1.getBindingValue(this._value);
                    for (var i = 0; i < data.length; i++) {
                        callback(value, i);
                    }
                }
                break;
            case types_1.BindingType.TEXTURE: {
                throw new common_1.RuntimeError("Texture binding does not support for each");
            }
        }
    };
    Binding.prototype.map = function (data) {
        switch (this.bindingType) {
            case types_1.BindingType.FUNCTION: {
                var f_1 = this._value;
                return data.map(function (d, i) { return types_1.getBindingValue(f_1(d, i)); });
            }
            case types_1.BindingType.VALUE: {
                var value_1 = types_1.getBindingValue(this._value);
                return data.map(function () { return value_1; });
            }
            case types_1.BindingType.TEXTURE: {
                throw new common_1.RuntimeError("Texture binding does not support for map");
            }
        }
    };
    Binding.prototype.fillBinary = function (data, rep, array) {
        var n = data.length;
        var p = this._type.primitiveCount;
        var ptr = 0;
        switch (this.bindingType) {
            case types_1.BindingType.FUNCTION:
                {
                    var f = this._value;
                    if (p == 1) {
                        for (var i = 0; i < n; i++) {
                            var result = types_1.getBindingValue(f(data[i], i));
                            for (var k = 0; k < rep; k++) {
                                array[ptr++] = result;
                            }
                        }
                    }
                    else {
                        for (var i = 0; i < n; i++) {
                            var result = types_1.getBindingValue(f(data[i], i));
                            for (var k = 0; k < rep; k++) {
                                for (var j = 0; j < p; j++) {
                                    array[ptr++] = result[j];
                                }
                            }
                        }
                    }
                }
                break;
            case types_1.BindingType.VALUE:
                {
                    var value = types_1.getBindingValue(this._value);
                    if (p == 1) {
                        var v = value;
                        for (var i = 0; i < n; i++) {
                            for (var k = 0; k < rep; k++) {
                                array[ptr++] = v;
                            }
                        }
                    }
                    else {
                        var v = value;
                        for (var i = 0; i < n; i++) {
                            for (var k = 0; k < rep; k++) {
                                for (var j = 0; j < p; j++) {
                                    array[ptr++] = v[j];
                                }
                            }
                        }
                    }
                }
                break;
            case types_1.BindingType.TEXTURE: {
                throw new common_1.RuntimeError("Texture binding does not support for fillBinary");
            }
        }
    };
    return Binding;
}());
exports.Binding = Binding;
//# sourceMappingURL=binding.js.map