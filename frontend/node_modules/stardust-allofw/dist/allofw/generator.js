"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var glsl_1 = require("../glsl/glsl");
var stardust_core_1 = require("stardust-core");
var stardust_core_2 = require("stardust-core");
var GenerateMode;
(function (GenerateMode) {
    GenerateMode[GenerateMode["NORMAL"] = 0] = "NORMAL";
    GenerateMode[GenerateMode["PICK"] = 1] = "PICK";
})(GenerateMode = exports.GenerateMode || (exports.GenerateMode = {}));
var ViewType;
(function (ViewType) {
    ViewType[ViewType["VIEW_2D"] = 0] = "VIEW_2D";
    ViewType[ViewType["VIEW_3D"] = 1] = "VIEW_3D";
})(ViewType = exports.ViewType || (exports.ViewType = {}));
var GLSLGeometryShaderGenerator = /** @class */ (function (_super) {
    __extends(GLSLGeometryShaderGenerator, _super);
    function GLSLGeometryShaderGenerator(parent) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        return _this;
    }
    GLSLGeometryShaderGenerator.prototype.addEmitStatement = function (sEmit) {
        for (var name_1 in sEmit.attributes) {
            this.addLine(this._parent._goutMapping.get(name_1) + " = " + this.generateExpression(sEmit.attributes[name_1]) + ";");
        }
        var position = this._parent._goutMapping.get("position");
        switch (this._parent._spec.output["position"].type) {
            case "Vector2":
                {
                    this.addLine("gl_Position = s3_render_vertex(vec3(" + position + ", 0.0));");
                }
                break;
            case "Vector3":
                {
                    this.addLine("gl_Position = s3_render_vertex(" + position + ");");
                }
                break;
            case "Vector4":
                {
                    this.addLine("gl_Position = s3_render_vertex(" + position + ".xyz);");
                }
                break;
        }
        this.addLine("EmitVertex();");
        this.addLine("s3_emit_count += 1;");
        this.addLine("if(s3_emit_count % 3 == 0) EndPrimitive();");
    };
    return GLSLGeometryShaderGenerator;
}(glsl_1.ShaderGenerator));
exports.GLSLGeometryShaderGenerator = GLSLGeometryShaderGenerator;
var GLSLFragmentShaderGenerator = /** @class */ (function (_super) {
    __extends(GLSLFragmentShaderGenerator, _super);
    function GLSLFragmentShaderGenerator(parent) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        return _this;
    }
    GLSLFragmentShaderGenerator.prototype.addEmitStatement = function (sEmit) {
        this.addLine(this._parent._fragmentOutputName + " = " + this.generateExpression(sEmit.attributes["color"]) + ";");
    };
    return GLSLFragmentShaderGenerator;
}(glsl_1.ShaderGenerator));
exports.GLSLFragmentShaderGenerator = GLSLFragmentShaderGenerator;
var Generator = /** @class */ (function (_super) {
    __extends(Generator, _super);
    function Generator(prefixCode, spec, shader, asUniform) {
        var _this = _super.call(this, spec, shader, asUniform) || this;
        _this._vertex = new glsl_1.ShaderGenerator();
        _this._geometry = new GLSLGeometryShaderGenerator(_this);
        _this._fragment = new GLSLFragmentShaderGenerator(_this);
        _this._geometry.addAdditionalCode(prefixCode);
        _this.compile();
        return _this;
    }
    Generator.prototype.compile = function () {
        var _this = this;
        var spec = this._spec;
        var shader = this._shader;
        var asUniform = this._asUniform;
        this._voutMapping = new stardust_core_1.Dictionary();
        this._goutMapping = new stardust_core_1.Dictionary();
        this._vertex.addLine("#version 330");
        this._geometry.addLine("#version 330");
        this._fragment.addLine("#version 330");
        this._geometry.addLine("layout(points) in;");
        var maxVertices = stardust_core_2.flattenEmits(spec).count;
        this._geometry.addLine("layout(triangle_strip, max_vertices = " + maxVertices + ") out;");
        // Input attributes
        for (var name_2 in spec.input) {
            if (spec.input.hasOwnProperty(name_2)) {
                if (asUniform(name_2)) {
                    this._geometry.addDeclaration(name_2, spec.input[name_2].type, "uniform");
                }
                else {
                    this._vertex.addDeclaration(name_2, spec.input[name_2].type, "in");
                    var vname = this.getUnusedName(name_2);
                    this._voutMapping.set(name_2, vname);
                    this._vertex.addDeclaration(vname, spec.input[name_2].type, "out");
                    this._geometry.addArrayDeclaration(vname, spec.input[name_2].type, 1, "in");
                }
            }
        }
        // Output attributes
        for (var name_3 in spec.output) {
            if (spec.output.hasOwnProperty(name_3)) {
                var oname = this.getUnusedName(name_3);
                this._goutMapping.set(name_3, oname);
                this._geometry.addDeclaration(oname, spec.output[name_3].type, "out");
            }
        }
        // Fragment shader inputs
        var fragment_passthrus = []; // gname, input_name
        for (var name_4 in shader.input) {
            if (shader.input.hasOwnProperty(name_4)) {
                if (this.fragmentPassthru(name_4)) {
                    var gname = this.getUnusedName(name_4);
                    fragment_passthrus.push([gname, name_4]);
                    this._geometry.addDeclaration(gname, shader.input[name_4].type, "out");
                    this._fragment.addDeclaration(gname, shader.input[name_4].type, "in");
                }
                else {
                    var gname = this._goutMapping.get(name_4);
                    this._fragment.addDeclaration(gname, shader.input[name_4].type, "in");
                }
            }
        }
        this._geometry.addAdditionalCode("\n            vec4 s3_render_vertex(vec3 p) {\n                return omni_render(omni_transform(p));\n            }\n        ");
        this._geometry.addLine("@additionalCode");
        // The vertex shader.
        this._vertex.addLine("void main() {");
        this._vertex.indent();
        for (var name_5 in spec.input) {
            if (spec.input.hasOwnProperty(name_5)) {
                if (!asUniform(name_5)) {
                    this._vertex.addLine(this._voutMapping.get(name_5) + " = " + name_5 + ";");
                }
            }
        }
        this._vertex.unindent();
        this._vertex.addLine("}");
        // The geometry shader.
        this._geometry.addLine("void main() {");
        this._geometry.indent();
        this._geometry.addLine("int s3_emit_count = 0;");
        for (var name_6 in spec.input) {
            if (spec.input.hasOwnProperty(name_6)) {
                if (!asUniform(name_6)) {
                    this._geometry.addDeclaration(name_6, spec.input[name_6].type);
                    this._geometry.addLine(name_6 + " = " + this._voutMapping.get(name_6) + "[0];");
                }
            }
        }
        // Define arguments.
        for (var name_7 in spec.variables) {
            if (spec.variables.hasOwnProperty(name_7)) {
                var type = spec.variables[name_7];
                this._geometry.addDeclaration(name_7, type);
            }
        }
        fragment_passthrus.forEach(function (_a) {
            var gname = _a[0], name = _a[1];
            _this._geometry.addLine(gname + " = " + name + ";");
        });
        this._geometry.addStatements(spec.statements);
        this._geometry.unindent();
        this._geometry.addLine("}");
        // The fragment shader
        this._fragmentOutputName = this.getUnusedName("fragmentColor");
        this._fragment.addLine("layout(location = 0) out vec4 " + this._fragmentOutputName + ";");
        this._fragment.addLine("void main() {");
        this._fragment.indent();
        var _loop_1 = function (name_8) {
            if (shader.input.hasOwnProperty(name_8)) {
                if (this_1.fragmentPassthru(name_8)) {
                    fragment_passthrus.forEach(function (_a) {
                        var gname = _a[0], vname = _a[1];
                        if (vname == name_8) {
                            _this._fragment.addLine(name_8 + " = " + gname + ";");
                        }
                    });
                }
                else {
                    this_1._fragment.addDeclaration(name_8, shader.input[name_8].type);
                    this_1._fragment.addLine(name_8 + " = " + this_1._goutMapping.get(name_8) + ";");
                }
            }
        };
        var this_1 = this;
        for (var name_8 in shader.input) {
            _loop_1(name_8);
        }
        for (var name_9 in shader.variables) {
            if (shader.variables.hasOwnProperty(name_9)) {
                var type = shader.variables[name_9];
                this._fragment.addDeclaration(name_9, type);
            }
        }
        this._fragment.addStatements(shader.statements);
        this._fragment.unindent();
        this._fragment.addLine("}");
    };
    Generator.prototype.getVertexCode = function () {
        return this._vertex.getCode();
    };
    Generator.prototype.getGeometryCode = function () {
        return this._geometry.getCode();
    };
    Generator.prototype.getFragmentCode = function () {
        return this._fragment.getCode();
    };
    return Generator;
}(glsl_1.ProgramGenerator));
exports.Generator = Generator;
//# sourceMappingURL=generator.js.map