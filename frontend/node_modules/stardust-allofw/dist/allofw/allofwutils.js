"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var allofw_1 = require("allofw");
function getShaderInfoLog(shader) {
    var buffer = new Buffer(4);
    allofw_1.GL3.getShaderiv(shader, allofw_1.GL3.INFO_LOG_LENGTH, buffer);
    var length = buffer.readUInt32LE(0);
    if (length > 0) {
        var buf = new Buffer(length);
        allofw_1.GL3.getShaderInfoLog(shader, length, buffer, buf);
        return buf.toString("utf-8");
    }
}
;
function isShaderCompiled(shader) {
    var buffer = new Buffer(4);
    allofw_1.GL3.getShaderiv(shader, allofw_1.GL3.COMPILE_STATUS, buffer);
    var success = buffer.readUInt32LE(0);
    return success != 0;
}
;
function isProgramLinked(program) {
    var buffer = new Buffer(4);
    allofw_1.GL3.getProgramiv(program, allofw_1.GL3.LINK_STATUS, buffer);
    var success = buffer.readUInt32LE(0);
    return success != 0;
}
;
function getProgramInfoLog(program) {
    var buffer = new Buffer(4);
    allofw_1.GL3.getProgramiv(program, allofw_1.GL3.INFO_LOG_LENGTH, buffer);
    var length = buffer.readUInt32LE(0);
    if (length > 0) {
        var buf = new Buffer(length);
        allofw_1.GL3.getProgramInfoLog(program, length, buffer, buf);
        return buf.toString("utf-8");
    }
}
;
var ShaderException = /** @class */ (function (_super) {
    __extends(ShaderException, _super);
    function ShaderException(type, message) {
        var _this = _super.call(this) || this;
        _this.message = "CompileShaders: " + type + ": " + message;
        _this.name = "ShaderException";
        return _this;
    }
    return ShaderException;
}(Error));
function compileShaders(shaders) {
    var shader_v, shader_f, shader_g;
    if (shaders.vertex) {
        shader_v = allofw_1.GL3.createShader(allofw_1.GL3.VERTEX_SHADER);
        allofw_1.GL3.shaderSource(shader_v, [shaders.vertex]);
        allofw_1.GL3.compileShader(shader_v);
        var log_1 = getShaderInfoLog(shader_v);
        if (log_1 && log_1.trim() != "") {
            console.log(log_1);
        }
        if (!isShaderCompiled(shader_v)) {
            throw new ShaderException("Vertex");
        }
    }
    if (shaders.fragment) {
        shader_f = allofw_1.GL3.createShader(allofw_1.GL3.FRAGMENT_SHADER);
        allofw_1.GL3.shaderSource(shader_f, [shaders.fragment]);
        allofw_1.GL3.compileShader(shader_f);
        var log_2 = getShaderInfoLog(shader_f);
        if (log_2 && log_2.trim() != "") {
            console.log(log_2);
        }
        if (!isShaderCompiled(shader_f)) {
            throw new ShaderException("Fragment");
        }
    }
    if (shaders.geometry) {
        shader_g = allofw_1.GL3.createShader(allofw_1.GL3.GEOMETRY_SHADER);
        allofw_1.GL3.shaderSource(shader_g, [shaders.geometry]);
        allofw_1.GL3.compileShader(shader_g);
        var log_3 = getShaderInfoLog(shader_g);
        if (log_3 && log_3.trim() != "") {
            console.log(log_3);
        }
        if (!isShaderCompiled(shader_g)) {
            throw new ShaderException("Geometry");
        }
    }
    var program = allofw_1.GL3.createProgram();
    if (shader_v)
        allofw_1.GL3.attachShader(program, shader_v);
    if (shader_f)
        allofw_1.GL3.attachShader(program, shader_f);
    if (shader_g)
        allofw_1.GL3.attachShader(program, shader_g);
    allofw_1.GL3.linkProgram(program);
    var log = getProgramInfoLog(program);
    if (log && log.trim() != "") {
        console.log(log);
    }
    if (!isProgramLinked(program)) {
        throw new ShaderException("Link");
    }
    return program;
}
exports.compileShaders = compileShaders;
;
function checkGLErrors(prefix) {
    if (prefix === void 0) { prefix = ""; }
    var error = allofw_1.GL3.getError();
    if (error != 0) {
        throw new Error("GLError at " + prefix + ": " + error);
    }
}
exports.checkGLErrors = checkGLErrors;
//# sourceMappingURL=allofwutils.js.map