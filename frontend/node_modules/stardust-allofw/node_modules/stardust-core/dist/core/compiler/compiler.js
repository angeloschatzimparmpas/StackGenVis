"use strict";
var exceptions_1 = require("../exceptions");
var parser_1 = require("./parser");
var utils_1 = require("../utils/utils");
var Intrinsics = require("../intrinsics/intrinsics");
var Library = require("../library/library");
var ModuleResolver = (function () {
    function ModuleResolver() {
        var _this = this;
        this._functions = new utils_1.Dictionary();
        this._functionModule = new utils_1.Dictionary();
        this._currentMoudles = [];
        Intrinsics.forEachIntrinsicFunction(function (info) {
            _this.addIntrinsicFunction(info.name, {
                type: "function",
                isMark: false,
                isShader: false,
                name: info.internalName,
                returnType: info.returnType,
                arguments: info.argTypes.map(function (x, idx) { return { name: "a" + idx, type: x }; }),
                statements: null
            });
        });
    }
    ModuleResolver.prototype.addIntrinsicFunction = function (name, func) {
        if (!this._functions.has(name)) {
            var resolver = new FunctionOverloadResolver(name);
            this._functions.set(name, resolver);
            resolver.addFunction(func);
        }
        else {
            var resolver = this._functions.get(name);
            resolver.addFunction(func);
        }
    };
    ModuleResolver.prototype.addFunction = function (name, func) {
        if (!this._functions.has(name)) {
            var resolver = new FunctionOverloadResolver(name);
            this._functions.set(name, resolver);
            resolver.addFunction(func);
        }
        else {
            var resolver = this._functions.get(name);
            resolver.addFunction(func);
        }
    };
    ModuleResolver.prototype.importFunction = function (module, name) {
        this.addFunction(name, module.get(name));
        this._functionModule.set(name, module);
    };
    ModuleResolver.prototype.getFunction = function (name) {
        for (var i = this._currentMoudles.length - 1; i >= 0; i--) {
            var cm = this._currentMoudles[i];
            if (cm && cm.has(name)) {
                var resolver = new FunctionOverloadResolver(name);
                resolver.addFunction(cm.get(name));
                return resolver;
            }
        }
        if (this._functions.has(name)) {
            return this._functions.get(name);
        }
        else {
            return null;
        }
    };
    ModuleResolver.prototype.enterFunctionImplementation = function (name) {
        this._currentMoudles.push(this._functionModule.get(name));
    };
    ModuleResolver.prototype.leaveFunctionImplementation = function (name) {
        this._currentMoudles.pop();
    };
    return ModuleResolver;
}());
exports.ModuleResolver = ModuleResolver;
var ScopeVariables = (function () {
    function ScopeVariables(owner, parentScope, argMap) {
        if (parentScope === void 0) { parentScope = null; }
        if (argMap === void 0) { argMap = null; }
        this._owner = owner;
        this._variables = new utils_1.Dictionary();
        this._parentScope = parentScope || null;
        this._argMap = argMap;
    }
    // Add a variable with name and type, shadows the ones from previous scopes.
    ScopeVariables.prototype.addVariable = function (name, type) {
        if (this._variables.has(name) || (this._argMap != null && this._argMap.has(name))) {
            // If the variable is defined in the current scope, throw exception.
            throw new exceptions_1.CompileError(name + " is already declared.");
        }
        else {
            // Create new translated name and set variable info.
            var translatedName = this._owner.newTranslatedName(name, type);
            this._variables.set(name, {
                name: name,
                type: type,
                translatedName: translatedName
            });
        }
    };
    // Create a new variable of type.
    ScopeVariables.prototype.nextVariable = function (type) {
        var _this = this;
        var name = utils_1.attemptName("tmp", function (name) { return !_this._variables.has(name) && !(_this._argMap != null && _this._argMap.has(name)); });
        this.addVariable(name, type);
        return this.getVariable(name);
    };
    ScopeVariables.prototype.getVariable = function (name) {
        if (this._variables.has(name)) {
            return this._variables.get(name);
        }
        else if (this._argMap != null && this._argMap.has(name)) {
            return this._parentScope.getVariable(this._argMap.get(name));
        }
        else if (this._parentScope) {
            return this._parentScope.getVariable(name);
        }
        else {
            throw new exceptions_1.CompileError(name + " is undefined.");
        }
    };
    Object.defineProperty(ScopeVariables.prototype, "parentScope", {
        get: function () {
            return this._parentScope;
        },
        enumerable: true,
        configurable: true
    });
    return ScopeVariables;
}());
exports.ScopeVariables = ScopeVariables;
var ScopeStack = (function () {
    function ScopeStack() {
        this._translatedNames = new utils_1.Dictionary();
        this._globalScope = new ScopeVariables(this);
        this._currentScope = this._globalScope;
    }
    // Reset scope to empty.
    ScopeStack.prototype.resetScope = function () {
        this._translatedNames = new utils_1.Dictionary();
        this._globalScope = new ScopeVariables(this);
        this._currentScope = this._globalScope;
    };
    // Push a scope.
    ScopeStack.prototype.pushScope = function (argMap) {
        if (argMap === void 0) { argMap = null; }
        this._currentScope = new ScopeVariables(this, this._currentScope, argMap);
    };
    // Pop a scope.
    ScopeStack.prototype.popScope = function () {
        this._currentScope = this._currentScope.parentScope;
    };
    // Create a new translated variable.
    ScopeStack.prototype.newTranslatedName = function (name, type) {
        var _this = this;
        var candidate = utils_1.attemptName(name, function (c) { return !_this._translatedNames.has(c); });
        this._translatedNames.set(candidate, {
            name: name,
            type: type,
            translatedName: candidate
        });
        return candidate;
    };
    // Iterate through translated variables.
    ScopeStack.prototype.forEach = function (callback) {
        this._translatedNames.forEach(function (o) {
            callback(o.translatedName, o.type);
        });
    };
    // Create a new variable in current scope, return its translated name.
    ScopeStack.prototype.nextVariableTranslatedName = function (type) {
        return this.nextVariable(type).translatedName;
    };
    // Create a new variable in current scope, return its name.
    ScopeStack.prototype.nextVariableName = function (type) {
        return this.nextVariable(type).name;
    };
    // Create a new variable in current scope, return its info.
    ScopeStack.prototype.nextVariable = function (type) {
        return this._currentScope.nextVariable(type);
    };
    // Add a new variable.
    ScopeStack.prototype.addVariable = function (name, type, scope) {
        if (scope == "global") {
            this._globalScope.addVariable(name, type);
        }
        else {
            this._currentScope.addVariable(name, type);
        }
    };
    // Translate variable from current scope to its translated name.
    ScopeStack.prototype.translateVariableName = function (name) {
        return this.getVariable(name).translatedName;
    };
    // Get variable info.
    ScopeStack.prototype.getVariable = function (name) {
        return this._currentScope.getVariable(name);
    };
    return ScopeStack;
}());
exports.ScopeStack = ScopeStack;
function typeConversionAttempt(src, dest) {
    var info = Intrinsics.getTypeConversion(src.valueType, dest);
    if (info) {
        var rank = info.rank;
        return [{
                type: "function",
                valueType: dest,
                arguments: [src],
                functionName: info.internalName,
            }, rank];
    }
    else {
        return [null, null];
    }
}
var FunctionOverloadResolver = (function () {
    function FunctionOverloadResolver(name) {
        this._name = name;
        this._functions = [];
    }
    FunctionOverloadResolver.prototype.addFunction = function (func) {
        this._functions.push(func);
    };
    FunctionOverloadResolver.prototype.resolveArguments = function (args, kwargs) {
        var result = null;
        var resultRank = null;
        for (var _i = 0, _a = this._functions; _i < _a.length; _i++) {
            var func = _a[_i];
            var funcRank = 0;
            var matched = true;
            var argExpressions = [];
            var argIndexUsed = [];
            var kwargsUsed = [];
            for (var argIndex in func.arguments) {
                var arg = func.arguments[argIndex];
                var argExpression = args[argIndex] || kwargs[arg.name];
                if (args[argIndex] != null) {
                    argIndexUsed.push(argIndex);
                }
                else if (kwargs[arg.name]) {
                    kwargsUsed.push(arg.name);
                }
                if (argExpression != null) {
                    if (argExpression.valueType != arg.type) {
                        var _b = typeConversionAttempt(argExpression, arg.type), conversion = _b[0], rank = _b[1];
                        if (conversion) {
                            argExpressions.push(conversion);
                            funcRank += rank;
                        }
                        else {
                            matched = false;
                            break;
                        }
                    }
                    else {
                        argExpressions.push(argExpression);
                    }
                }
                else {
                    if (arg.default === null || arg.default === undefined) {
                        matched = false;
                        break;
                    }
                    else {
                        argExpressions.push({
                            type: "constant",
                            value: arg.default,
                            valueType: arg.type
                        });
                    }
                }
            }
            var isAllUsed = true;
            for (var argIndex in args) {
                if (argIndexUsed.indexOf(argIndex) < 0)
                    isAllUsed = false;
            }
            for (var argName in kwargs) {
                if (kwargsUsed.indexOf(argName) < 0)
                    isAllUsed = false;
            }
            if (matched && isAllUsed) {
                if (!result || funcRank < resultRank) {
                    result = [func, argExpressions];
                    resultRank = funcRank;
                }
            }
        }
        if (result) {
            return result;
        }
        else {
            var argspec = args.map(function (x) { return x.valueType; }).join(", ");
            throw new exceptions_1.CompileError("unable to resolve function '" + this._name + "' with arguments (" + argspec + ")");
        }
    };
    return FunctionOverloadResolver;
}());
exports.FunctionOverloadResolver = FunctionOverloadResolver;
var Compiler = (function () {
    function Compiler() {
        this._scope = new ScopeStack();
        // this._functions = new Dictionary<FunctionOverloadResolver>();
        // this._intrinsicFunctions = new Dictionary<FunctionOverloadResolver>();
        this._constants = new utils_1.Dictionary();
        this._moduleResolver = new ModuleResolver();
        this._statements = [];
        this._lastIndex = 1;
        this.prepareFieldTypeRegistry();
        this.prepareConstants();
    }
    Compiler.prototype.prepareFieldTypeRegistry = function () {
        this._fieldTypeRegistry = {};
        var r = this._fieldTypeRegistry;
        for (var _i = 0, _a = ["x", "y"]; _i < _a.length; _i++) {
            var f = _a[_i];
            r[("Vector2." + f)] = "float";
        }
        for (var _b = 0, _c = ["x", "y", "z", "r", "g", "b"]; _b < _c.length; _b++) {
            var f = _c[_b];
            r[("Vector3." + f)] = "float";
        }
        for (var _d = 0, _e = ["x", "y", "z", "w", "r", "g", "b", "a"]; _d < _e.length; _d++) {
            var f = _e[_d];
            r[("Vector4." + f)] = "float";
        }
        for (var _f = 0, _g = ["r", "g", "b", "a"]; _f < _g.length; _f++) {
            var f = _g[_f];
            r[("Color." + f)] = "float";
        }
    };
    Compiler.prototype.prepareConstants = function () {
        var _this = this;
        Intrinsics.forEachConstant(function (info) {
            _this._constants.set(info.name, info);
        });
    };
    Compiler.prototype.resolveFunction = function (name, args, kwargs) {
        var resolver = this._moduleResolver.getFunction(name);
        if (resolver) {
            return resolver.resolveArguments(args, kwargs);
        }
        else {
            throw new exceptions_1.CompileError("function '" + name + " is undefined.");
        }
    };
    Compiler.prototype.loadFile = function (file) {
        var _this = this;
        var _loop_1 = function(block) {
            if (block.type == "function") {
                var blockFunction = block;
                this_1._moduleResolver.addFunction(blockFunction.name, blockFunction);
            }
            if (block.type == "import") {
                var blockImport_1 = block;
                if (blockImport_1.functionNames != null) {
                    blockImport_1.functionNames.forEach(function (name) {
                        _this._moduleResolver.importFunction(Library.getModule(blockImport_1.moduleName), name);
                    });
                }
                else {
                    var module_1 = Library.getModule(blockImport_1.moduleName);
                    module_1.forEach(function (func, name) {
                        _this._moduleResolver.importFunction(module_1, name);
                    });
                }
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {
            var block = _a[_i];
            _loop_1(block);
        }
    };
    Compiler.prototype.getDefaultValueForType = function (type) {
        if (type == "float")
            return 0;
        if (type == "Vector2")
            return [0, 0];
        if (type == "Vector3")
            return [0, 0, 0];
        if (type == "Vector4")
            return [0, 0, 0, 0];
        if (type == "Color")
            return [0, 0, 0, 1];
        if (type == "Quaternion")
            return [0, 0, 0, 1];
        return 0;
    };
    Compiler.prototype.compileFunctionToMark = function (globals, block) {
        // Re-init state.
        this._scope.resetScope();
        this._lastIndex = 1;
        var markInput = {};
        var markOutput = {};
        var markVariables = {};
        // Setup input parameters.
        for (var _i = 0, globals_1 = globals; _i < globals_1.length; _i++) {
            var global = globals_1[_i];
            this._scope.addVariable(global.name, global.valueType, "global");
            markInput[global.name] = {
                type: global.valueType,
                default: global.default || this.getDefaultValueForType(global.valueType)
            };
        }
        for (var _a = 0, _b = block.arguments; _a < _b.length; _a++) {
            var arg = _b[_a];
            this._scope.addVariable(arg.name, arg.type, "local");
            markInput[arg.name] = {
                type: arg.type,
                default: arg.default || this.getDefaultValueForType(arg.type)
            };
        }
        // Flatten statements.
        this.compileStatements({
            type: "statements",
            statements: block.statements
        });
        // Figure out variables.
        this._scope.forEach(function (name, type) {
            if (!markInput[name]) {
                markVariables[name] = type;
            }
        });
        // Figure out outputs.
        var processStatementsForOutputs = function (statements) {
            statements.forEach(function (x) {
                if (x.type == "emit") {
                    var sEmit = x;
                    for (var attr in sEmit.attributes) {
                        if (markOutput.hasOwnProperty(attr)) {
                            if (markOutput[attr].type != sEmit.attributes[attr].valueType) {
                                throw new exceptions_1.CompileError("output variable '" + attr + " has conflicting types.");
                            }
                        }
                        else {
                            markOutput[attr] = { type: sEmit.attributes[attr].valueType };
                        }
                    }
                }
                if (x.type == "condition") {
                    var sCondition = x;
                    processStatementsForOutputs(sCondition.trueStatements);
                    processStatementsForOutputs(sCondition.falseStatements);
                }
                if (x.type == "for") {
                    var sForLoop = x;
                    processStatementsForOutputs(sForLoop.statements);
                }
            });
        };
        processStatementsForOutputs(this._statements);
        return {
            input: markInput,
            output: markOutput,
            variables: markVariables,
            statements: this._statements
        };
    };
    Compiler.prototype.addStatement = function (statement) {
        this._statements.push(statement);
    };
    Compiler.prototype.addStatements = function (statements) {
        this._statements = this._statements.concat(statements);
    };
    Compiler.prototype.captureStatements = function (callback) {
        var currentStatements = this._statements;
        this._statements = [];
        callback();
        var result = this._statements;
        this._statements = currentStatements;
        return result;
    };
    Compiler.prototype.compileExpression = function (expression) {
        switch (expression.type) {
            case "value": {
                var expr = expression;
                return {
                    type: "constant",
                    value: expr.value,
                    valueType: expr.valueType
                };
            }
            case "variable": {
                var expr = expression;
                if (this._constants.has(expr.name)) {
                    var cinfo = this._constants.get(expr.name);
                    return {
                        type: "constant",
                        value: cinfo.value,
                        valueType: cinfo.type
                    };
                }
                else {
                    return {
                        type: "variable",
                        variableName: this._scope.translateVariableName(expr.name),
                        valueType: this._scope.getVariable(expr.name).type
                    };
                }
            }
            case "field": {
                var expr = expression;
                var valueExpr = this.compileExpression(expr.value);
                return {
                    type: "field",
                    fieldName: expr.fieldName,
                    value: valueExpr,
                    valueType: this._fieldTypeRegistry[valueExpr.valueType + "." + expr.fieldName]
                };
            }
            case "function": {
                var expr = expression;
                var args = [];
                var kwargs = {};
                for (var _i = 0, _a = expr.args.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    args.push(this.compileExpression(arg));
                }
                for (var key in expr.args.kwargs) {
                    var e = expr.args.kwargs[key];
                    kwargs[key] = this.compileExpression(expr.args.kwargs[key]);
                }
                var _b = this.resolveFunction(expr.name, args, kwargs), func = _b[0], argExpressions = _b[1];
                var returnValueExpression = null;
                if (!func.statements) {
                    returnValueExpression = {
                        type: "function",
                        functionName: func.name,
                        arguments: argExpressions,
                        valueType: func.returnType
                    };
                }
                else {
                    var argMap = new utils_1.Dictionary();
                    for (var argIndex in func.arguments) {
                        var arg = func.arguments[argIndex];
                        var mapped = this._scope.nextVariableName(arg.type);
                        argMap.set(arg.name, mapped);
                        this.addStatement({
                            type: "assign",
                            variableName: this._scope.translateVariableName(mapped),
                            expression: argExpressions[argIndex]
                        });
                    }
                    this._scope.pushScope(argMap);
                    this._moduleResolver.enterFunctionImplementation(expr.name);
                    for (var _c = 0, _d = func.statements; _c < _d.length; _c++) {
                        var statement = _d[_c];
                        if (statement.type == "return") {
                            var statement_return = statement;
                            returnValueExpression = this.compileExpression(statement_return.value);
                            break;
                        }
                        else {
                            this.compileStatement(statement);
                        }
                    }
                    this._moduleResolver.leaveFunctionImplementation(expr.name);
                    this._scope.popScope();
                }
                return returnValueExpression;
            }
        }
        return null;
    };
    Compiler.prototype.compileStandaloneExpression = function (expression, variables) {
        switch (expression.type) {
            case "value": {
                var expr = expression;
                return {
                    type: "constant",
                    value: expr.value,
                    valueType: expr.valueType
                };
            }
            case "variable": {
                var expr = expression;
                if (variables.has(expr.name)) {
                    return variables.get(expr.name);
                }
                else {
                    if (this._constants.has(expr.name)) {
                        var cinfo = this._constants.get(expr.name);
                        return {
                            type: "constant",
                            value: cinfo.value,
                            valueType: cinfo.type
                        };
                    }
                    else {
                        throw new exceptions_1.CompileError("variable " + expr.name + " is undefined");
                    }
                }
            }
            case "field": {
                var expr = expression;
                var valueExpr = this.compileStandaloneExpression(expr.value, variables);
                return {
                    type: "field",
                    fieldName: expr.fieldName,
                    value: valueExpr,
                    valueType: this._fieldTypeRegistry[valueExpr.valueType + "." + expr.fieldName]
                };
            }
            case "function": {
                var expr = expression;
                var args = [];
                var kwargs = {};
                for (var _i = 0, _a = expr.args.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    args.push(this.compileStandaloneExpression(arg, variables));
                }
                for (var key in expr.args.kwargs) {
                    var e = expr.args.kwargs[key];
                    kwargs[key] = this.compileStandaloneExpression(expr.args.kwargs[key], variables);
                }
                var _b = this.resolveFunction(expr.name, args, kwargs), func = _b[0], argExpressions = _b[1];
                return {
                    type: "function",
                    functionName: func.name,
                    arguments: argExpressions,
                    valueType: func.returnType
                };
            }
        }
        return null;
    };
    Compiler.prototype.compileStatements = function (statements) {
        this._scope.pushScope();
        for (var _i = 0, _a = statements.statements; _i < _a.length; _i++) {
            var s = _a[_i];
            this.compileStatement(s);
        }
        this._scope.popScope();
    };
    Compiler.prototype.compileStatement = function (statement) {
        var _this = this;
        switch (statement.type) {
            case "declare":
                {
                    var s = statement;
                    if (s.initial) {
                        var ve = this.compileExpression(s.initial);
                        var variableType = s.variableType;
                        if (variableType == "auto")
                            variableType = ve.valueType;
                        this._scope.addVariable(s.variableName, variableType, "local");
                        if (ve.valueType != variableType) {
                            var veType = ve.valueType;
                            ve = typeConversionAttempt(ve, this._scope.getVariable(s.variableName).type)[0];
                            if (ve === null) {
                                throw new exceptions_1.CompileError("cannot convert type '" + veType + "' to '" + variableType + "'.");
                            }
                        }
                        this.addStatement({
                            type: "assign",
                            variableName: this._scope.translateVariableName(s.variableName),
                            expression: ve
                        });
                    }
                    else {
                        this._scope.addVariable(s.variableName, s.variableType, "local");
                    }
                }
                break;
            case "expression":
                {
                    var s = statement;
                    this.compileExpression(s.expression);
                }
                break;
            case "assign":
                {
                    var s = statement;
                    var ve = this.compileExpression(s.expression);
                    var targetType = this._scope.getVariable(s.variableName).type;
                    if (ve.valueType != targetType) {
                        var veType = ve.valueType;
                        ve = typeConversionAttempt(ve, this._scope.getVariable(s.variableName).type)[0];
                        if (ve === null) {
                            throw new exceptions_1.CompileError("cannot convert type '" + veType + " to '" + targetType + "'.");
                        }
                    }
                    this.addStatement({
                        type: "assign",
                        variableName: this._scope.translateVariableName(s.variableName),
                        expression: ve
                    });
                }
                break;
            case "emit":
                {
                    var s = statement;
                    s.vertices.forEach(function (v) {
                        var attrs = {};
                        for (var argName in v) {
                            var expr = v[argName];
                            attrs[argName] = _this.compileExpression(expr);
                        }
                        _this.addStatement({
                            type: "emit",
                            attributes: attrs
                        });
                    });
                }
                break;
            case "statements":
                {
                    var s = statement;
                    this.compileStatements(s);
                }
                break;
            case "for":
                {
                    var s_1 = statement;
                    this._scope.pushScope();
                    // Declare the loop variable
                    this._scope.addVariable(s_1.variableName, "int", "local");
                    var loopVariable = this._scope.translateVariableName(s_1.variableName);
                    // Compile for statements
                    var forStatement = {
                        type: "for",
                        variableName: loopVariable,
                        rangeMin: s_1.start,
                        rangeMax: s_1.end,
                        statements: this.captureStatements(function () { return _this.compileStatement(s_1.statement); })
                    };
                    this.addStatement(forStatement);
                    this._scope.popScope();
                }
                break;
            case "if":
                {
                    var s_2 = statement;
                    // Function to compile the i-th condition in the if-elseif-else syntax.
                    var compileIthCondition_1 = function (i) {
                        if (i < s_2.conditions.length) {
                            var statements = [];
                            _this._scope.pushScope();
                            var ve = _this.compileExpression(s_2.conditions[i].condition);
                            var cond = {
                                type: "condition",
                                condition: ve,
                                trueStatements: _this.captureStatements(function () { return _this.compileStatement(s_2.conditions[i].statement); }),
                                falseStatements: _this.captureStatements(function () { return compileIthCondition_1(i + 1); })
                            };
                            _this.addStatement(cond);
                            _this._scope.popScope();
                        }
                        else {
                            if (s_2.else) {
                                _this.compileStatement(s_2.else);
                            }
                        }
                    };
                    compileIthCondition_1(0);
                }
                break;
            case "return": {
                throw new exceptions_1.CompileError("unexpected return statement");
            }
        }
    };
    return Compiler;
}());
exports.Compiler = Compiler;
function compileTree(file) {
    var spec = {};
    var globals = file.blocks.filter(function (x) { return x.type == "global"; });
    for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {
        var block = _a[_i];
        if (block.type == "function") {
            var blockFunction = block;
            if (blockFunction.isMark || blockFunction.isShader) {
                var scope = new Compiler();
                scope.loadFile(file);
                var mark = scope.compileFunctionToMark(globals, blockFunction);
                spec[blockFunction.name] = mark;
            }
        }
    }
    return spec;
}
exports.compileTree = compileTree;
var standaloneCompiler = new Compiler();
function compileExpression(expr, variables) {
    return standaloneCompiler.compileStandaloneExpression(expr, variables);
}
exports.compileExpression = compileExpression;
function compileString(content) {
    var file = parser_1.parseFile(content);
    return compileTree(file);
}
exports.compileString = compileString;
//# sourceMappingURL=compiler.js.map