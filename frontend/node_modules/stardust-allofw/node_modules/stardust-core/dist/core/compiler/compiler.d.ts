import { Specification } from "../spec/spec";
import { SyntaxTree } from "./parser";
import { Dictionary } from "../utils/utils";
export interface ScopeVariableInfo {
    name: string;
    type: string;
    translatedName: string;
}
export declare class ModuleResolver {
    private _functions;
    private _functionModule;
    private _currentMoudles;
    constructor();
    addIntrinsicFunction(name: string, func: SyntaxTree.FileBlockFunction): void;
    addFunction(name: string, func: SyntaxTree.FileBlockFunction): void;
    importFunction(module: Dictionary<SyntaxTree.FileBlockFunction>, name: string): void;
    getFunction(name: string): FunctionOverloadResolver;
    enterFunctionImplementation(name: string): void;
    leaveFunctionImplementation(name: string): void;
}
export declare class ScopeVariables {
    private _owner;
    private _variables;
    private _parentScope;
    private _argMap;
    constructor(owner: ScopeStack, parentScope?: ScopeVariables, argMap?: Dictionary<string>);
    addVariable(name: string, type: string): void;
    nextVariable(type: string): ScopeVariableInfo;
    getVariable(name: string): ScopeVariableInfo;
    readonly parentScope: ScopeVariables;
}
export declare class ScopeStack {
    private _currentScope;
    private _globalScope;
    private _translatedNames;
    constructor();
    resetScope(): void;
    pushScope(argMap?: Dictionary<string>): void;
    popScope(): void;
    newTranslatedName(name: string, type: string): string;
    forEach(callback: (name: string, type: string) => void): void;
    nextVariableTranslatedName(type: string): string;
    nextVariableName(type: string): string;
    nextVariable(type: string): ScopeVariableInfo;
    addVariable(name: string, type: string, scope: "local" | "global"): void;
    translateVariableName(name: string): string;
    getVariable(name: string): ScopeVariableInfo;
}
export declare class FunctionOverloadResolver {
    private _name;
    private _functions;
    constructor(name: string);
    addFunction(func: SyntaxTree.FileBlockFunction): void;
    resolveArguments(args: Specification.Expression[], kwargs: {
        [name: string]: Specification.Expression;
    }): [SyntaxTree.FileBlockFunction, Specification.Expression[]];
}
export declare class Compiler {
    private _scope;
    private _constants;
    private _statements;
    private _moduleResolver;
    private _lastIndex;
    private _fieldTypeRegistry;
    constructor();
    prepareFieldTypeRegistry(): void;
    prepareConstants(): void;
    resolveFunction(name: string, args: Specification.Expression[], kwargs: {
        [name: string]: Specification.Expression;
    }): [SyntaxTree.FileBlockFunction, Specification.Expression[]];
    loadFile(file: SyntaxTree.File): void;
    getDefaultValueForType(type: string): number | number[];
    compileFunctionToMark(globals: SyntaxTree.FileBlockGlobal[], block: SyntaxTree.FileBlockFunction): Specification.Mark;
    addStatement(statement: Specification.Statement): void;
    addStatements(statements: Specification.Statement[]): void;
    captureStatements(callback: () => void): Specification.Statement[];
    compileExpression(expression: SyntaxTree.Expression): Specification.Expression;
    compileStandaloneExpression(expression: SyntaxTree.Expression, variables: Dictionary<Specification.Expression>): Specification.Expression;
    compileStatements(statements: SyntaxTree.StatementStatements): void;
    compileStatement(statement: SyntaxTree.Statement): void;
}
export declare function compileTree(file: SyntaxTree.File): Specification.Marks;
export declare function compileExpression(expr: SyntaxTree.Expression, variables: Dictionary<Specification.Expression>): Specification.Expression;
export declare function compileString(content: string): Specification.Marks;
