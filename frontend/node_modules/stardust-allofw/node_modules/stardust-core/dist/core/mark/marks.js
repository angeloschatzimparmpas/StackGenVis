"use strict";
var compiler_1 = require("../compiler/compiler");
var declare_1 = require("../compiler/declare");
var mark_1 = require("./mark");
var platform_1 = require("../platform/platform");
var mark;
(function (mark) {
    function create(arg1, arg2, arg3) {
        if (arg2 instanceof platform_1.Platform) {
            var default_shader = shader.basic();
            if (arg1 instanceof declare_1.CustomMark) {
                return new mark_1.Mark(arg1.compile(), default_shader, arg2);
            }
            else {
                return new mark_1.Mark(arg1, default_shader, arg2);
            }
        }
        else {
            var default_shader = arg2;
            if (arg1 instanceof declare_1.CustomMark) {
                return new mark_1.Mark(arg1.compile(), default_shader, arg3);
            }
            else {
                return new mark_1.Mark(arg1, default_shader, arg3);
            }
        }
    }
    mark.create = create;
    // export function create(spec: CustomMark | Specification.Mark, platform: Platform): Mark {
    //     if(spec instanceof CustomMark) {
    //         return new Mark(spec.compile(), platform);
    //     } else {
    //         return new Mark(spec, platform);
    //     }
    // }
    function custom() {
        return new declare_1.CustomMark();
    }
    mark.custom = custom;
    function compile(code) {
        return compiler_1.compileString(code);
    }
    mark.compile = compile;
    function circle(sides) {
        if (sides === void 0) { sides = 32; }
        return mark.compile("\n            mark Circle(\n                center: Vector2 = [ 0, 0 ],\n                radius: float = 1,\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                for(i in 0.." + (sides - 1) + ") {\n                    let a1 = i / " + sides.toFixed(1) + " * PI * 2.0;\n                    let a2 = (i + 1) / " + sides.toFixed(1) + " * PI * 2.0;\n                    let p1 = Vector2(radius * cos(a1), radius * sin(a1));\n                    let p2 = Vector2(radius * cos(a2), radius * sin(a2));\n                    emit [\n                        { position: center + p1, color: color },\n                        { position: center, color: color },\n                        { position: center + p2, color: color }\n                    ];\n                }\n            }\n        ")["Circle"];
    }
    mark.circle = circle;
    function rect() {
        return mark.compile("\n            mark Rectangle(\n                p1: Vector2 = [ 0, 0 ],\n                p2: Vector2 = [ 0, 0 ],\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                emit [\n                    { position: Vector2(p1.x, p1.y), color: color },\n                    { position: Vector2(p2.x, p1.y), color: color },\n                    { position: Vector2(p2.x, p2.y), color: color }\n                ];\n                emit [\n                    { position: Vector2(p1.x, p1.y), color: color },\n                    { position: Vector2(p1.x, p2.y), color: color },\n                    { position: Vector2(p2.x, p2.y), color: color }\n                ];\n            }\n        ")["Rectangle"];
    }
    mark.rect = rect;
    function line() {
        return mark.compile("\n            mark Line(\n                p1: Vector2 = [ 0, 0 ],\n                p2: Vector2 = [ 0, 0 ],\n                width: float = 1,\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                let d = normalize(p2 - p1);\n                let t = Vector2(d.y, -d.x) * (width / 2);\n                emit [\n                    { position: p1 + t, color: color },\n                    { position: p1 - t, color: color },\n                    { position: p2 + t, color: color }\n                ];\n                emit [\n                    { position: p1 - t, color: color },\n                    { position: p2 - t, color: color },\n                    { position: p2 + t, color: color }\n                ];\n            }\n        ")["Line"];
    }
    mark.line = line;
    function wedge(sides) {
        if (sides === void 0) { sides = 60; }
        return mark.compile("\n            import { Triangle } from P2D;\n\n            mark Wedge(\n                p1: Vector2 = [ 0, 0 ],\n                theta1: float = 0,\n                theta2: float = 0,\n                length: float = 10,\n                width: float = 1,\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                let dTheta = (theta2 - theta1) / 60;\n                let dL = length / 60;\n                for(i in 0..59) {\n                    let dThetaA = i * dTheta;\n                    let dThetaB = (i + 1) * dTheta;\n                    let thetaA = theta1 + dThetaA;\n                    let thetaB = theta1 + dThetaB;\n                    let thetaCenterA = theta1 + dThetaA / 2;\n                    let thetaCenterB = theta1 + dThetaB / 2;\n                    let dlA = dL * i;\n                    let dlB = dL * (i + 1);\n                    if(dThetaA > 1e-5 || dThetaA < -1e-5) {\n                        dlA = dlA / dThetaA * 2 * sin(dThetaA / 2);\n                    }\n                    if(dThetaB > 1e-5 || dThetaB < -1e-5) {\n                        dlB = dlB / dThetaB * 2 * sin(dThetaB / 2);\n                    }\n                    let pAdvA = Vector2(-sin(thetaCenterA), cos(thetaCenterA)) * dlA;\n                    let pAdvB = Vector2(-sin(thetaCenterB), cos(thetaCenterB)) * dlB;\n                    let pA = p1 + pAdvA;\n                    let pB = p1 + pAdvB;\n\n                    let dpA = Vector2(cos(thetaA), sin(thetaA)) * width * 0.5;\n                    let dpB = Vector2(cos(thetaB), sin(thetaB)) * width * 0.5;\n\n                    Triangle(pA + dpA, pB + dpB, pB - dpB, color);\n                    Triangle(pA + dpA, pB - dpB, pA - dpA, color);\n                }\n            }\n        ")["Wedge"];
    }
    mark.wedge = wedge;
    function polyline() {
        var spec = mark.compile("\n            import { Triangle } from P2D;\n\n            mark Sector2(\n                c: Vector2,\n                p1: Vector2,\n                p2: Vector2,\n                color: Color\n            ) {\n                let pc = c + normalize(p1 + p2 - c - c) * length(p1 - c);\n                Triangle(c, p1, pc, color);\n                Triangle(c, pc, p2, color);\n            }\n\n            mark Sector4(\n                c: Vector2,\n                p1: Vector2,\n                p2: Vector2,\n                color: Color\n            ) {\n                let pc = c + normalize(p1 + p2 - c - c) * length(p1 - c);\n                Sector2(c, p1, pc, color);\n                Sector2(c, pc, p2, color);\n            }\n\n            mark PolylineRound(\n                p: Vector2, p_p: Vector2, p_n: Vector2, p_nn: Vector2,\n                width: float = 1,\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                let EPS = 1e-5;\n                let w = width / 2;\n                let d = normalize(p - p_n);\n                let n = Vector2(d.y, -d.x);\n                let m1: Vector2;\n                if(length(p - p_p) < EPS) {\n                    m1 = n * w;\n                } else {\n                    m1 = normalize(d + normalize(p - p_p)) * w;\n                }\n                let m2: Vector2;\n                if(length(p_n - p_nn) < EPS) {\n                    m2 = -n * w;\n                } else {\n                    m2 = normalize(normalize(p_n - p_nn) - d) * w;\n                }\n                let c1a: Vector2;\n                let c1b: Vector2;\n                let a1: Vector2;\n                let a2: Vector2;\n                if(dot(m1, n) > 0) {\n                    c1a = p + m1;\n                    c1b = p + n * w;\n                    a2 = c1b;\n                    a1 = p - m1 * (w / dot(m1, n));\n                } else {\n                    c1a = p + m1;\n                    c1b = p - n * w;\n                    a2 = p + m1 * (w / dot(m1, n));\n                    a1 = c1b;\n                }\n                let c2a: Vector2;\n                let c2b: Vector2;\n                let b1: Vector2;\n                let b2: Vector2;\n                if(dot(m2, n) < 0) {\n                    c2a = p_n + m2;\n                    c2b = p_n - n * w;\n                    b1 = c2b;\n                    b2 = p_n + m2 * (w / dot(m2, n));\n                } else {\n                    c2a = p_n + m2;\n                    c2b = p_n + n * w;\n                    b2 = c2b;\n                    b1 = p_n - m2 * (w / dot(m2, n));\n                }\n                Sector4(p, c1a, c1b, color);\n                Sector4(p_n, c2a, c2b, color);\n                Triangle(p, a1, b1, color);\n                Triangle(p, b1, p_n, color);\n                Triangle(p, a2, b2, color);\n                Triangle(p, b2, p_n, color);\n            }\n        ")["PolylineRound"];
        spec.repeatBegin = 1;
        spec.repeatEnd = 1;
        return spec;
    }
    mark.polyline = polyline;
})(mark = exports.mark || (exports.mark = {}));
var shader;
(function (shader) {
    function compile(code) {
        return compiler_1.compileString(code);
    }
    shader.compile = compile;
    function basic() {
        return shader.compile("\n            shader Default(\n                color: Color = [ 0, 0, 0, 1 ]\n            ) {\n                emit { color: color };\n            }\n        ")["Default"];
    }
    shader.basic = basic;
    function lighting() {
        return shader.compile("\n            shader Default(\n                color: Color = [ 0, 0, 0, 1 ],\n                normal: Vector3,\n                position: Vector3\n            ) {\n                let lighting = normalize(position);\n                let NdotL = abs(dot(normal, lighting));\n                let s = NdotL * 0.5 + 0.5;\n                emit { color: Color(s * color.r, s * color.g, s * color.b, color.a) };\n            }\n        ")["Default"];
    }
    shader.lighting = lighting;
})(shader = exports.shader || (exports.shader = {}));
//# sourceMappingURL=marks.js.map