"use strict";
var exceptions_1 = require("../exceptions");
var utils_1 = require("../utils/utils");
var Intrinsics = require("../intrinsics/intrinsics");
var Context = (function () {
    function Context() {
        this._variables = new utils_1.Dictionary();
    }
    Context.prototype.get = function (name) {
        if (!this._variables.has(name)) {
            throw new exceptions_1.RuntimeError("'" + name + "' is undefined.");
        }
        return this._variables.get(name);
    };
    Context.prototype.set = function (name, value) {
        this._variables.set(name, value);
    };
    Context.prototype.evaluateExpression = function (expression) {
        var _this = this;
        switch (expression.type) {
            case "function": {
                var expr = expression;
                var args = expr.arguments.map(function (arg) { return _this.evaluateExpression(arg); });
                var func = Intrinsics.getIntrinsicFunction(expr.functionName);
                if (!func) {
                    throw new exceptions_1.RuntimeError("function '" + expr.functionName + "' is undefined.");
                }
                return func.javascriptImplementation.apply(func, args);
            }
            case "field": {
                var expr = expression;
                var value = this.evaluateExpression(expr.value);
                switch (expr.fieldName) {
                    case "x": return value[0];
                    case "y": return value[1];
                    case "z": return value[2];
                    case "w": return value[3];
                    case "r": return value[0];
                    case "g": return value[1];
                    case "b": return value[2];
                    case "a": return value[3];
                }
                throw new exceptions_1.RuntimeError("invalid field.");
            }
            case "constant": {
                var expr = expression;
                return expr.value;
            }
            case "variable": {
                var expr = expression;
                return this.get(expr.variableName);
            }
        }
    };
    Context.prototype.evaluateStatement = function (statement) {
        switch (statement.type) {
            case "assign": {
                var s = statement;
                this.set(s.variableName, this.evaluateExpression(s.expression));
                return [];
            }
            case "condition": {
                var s = statement;
                var condition = this.evaluateExpression(s.condition);
                if (condition != 0) {
                    return this.evaluateStatements(s.trueStatements);
                }
                else {
                    return this.evaluateStatements(s.falseStatements);
                }
            }
            case "emit": {
                var s = statement;
                var emitInfo = {};
                for (var name_1 in s.attributes) {
                    var value = this.evaluateExpression(s.attributes[name_1]);
                    emitInfo[name_1] = value;
                }
                return [emitInfo];
            }
        }
    };
    Context.prototype.evaluateStatements = function (statements) {
        var result = [];
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var s = statements_1[_i];
            var v = this.evaluateStatement(s);
            for (var _a = 0, v_1 = v; _a < v_1.length; _a++) {
                var r = v_1[_a];
                result.push(r);
            }
        }
        return result;
    };
    Context.prototype.evaluateMark = function (mark, inputs) {
        for (var name_2 in inputs) {
            this.set(name_2, inputs[name_2]);
        }
        return this.evaluateStatements(mark.statements);
    };
    return Context;
}());
exports.Context = Context;
//# sourceMappingURL=evaluator.js.map