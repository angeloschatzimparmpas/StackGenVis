"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var stardust_core_1 = require("stardust-core");
var glsl_1 = require("../glsl/glsl");
var GenerateMode;
(function (GenerateMode) {
    GenerateMode[GenerateMode["NORMAL"] = 0] = "NORMAL";
    GenerateMode[GenerateMode["PICK"] = 1] = "PICK";
    GenerateMode[GenerateMode["FRAGMENT"] = 2] = "FRAGMENT";
})(GenerateMode = exports.GenerateMode || (exports.GenerateMode = {}));
var ViewType;
(function (ViewType) {
    ViewType[ViewType["VIEW_2D"] = 0] = "VIEW_2D";
    ViewType[ViewType["VIEW_3D"] = 1] = "VIEW_3D";
    ViewType[ViewType["VIEW_MATRIX"] = 2] = "VIEW_MATRIX"; // Matrix mode.
})(ViewType = exports.ViewType || (exports.ViewType = {}));
var GLSLVertexShaderGenerator = /** @class */ (function (_super) {
    __extends(GLSLVertexShaderGenerator, _super);
    function GLSLVertexShaderGenerator(parent) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        return _this;
    }
    GLSLVertexShaderGenerator.prototype.addEmitStatement = function (sEmit) {
        for (var name_1 in sEmit.attributes) {
            this.addLine(this._parent._voutMapping.get(name_1) + " = " + this.generateExpression(sEmit.attributes[name_1]) + ";");
        }
        if (this._parent._mode == GenerateMode.PICK) {
            this.addLine("out_pick_index = vec4(s3_pick_index.rgb, s3_pick_index_alpha);");
        }
        var position = this._parent._voutMapping.get("position");
        switch (this._parent._spec.output.position.type) {
            case "Vector2":
                {
                    this.addLine("gl_Position = s3_render_vertex(vec3(" + position + ", 0.0));");
                }
                break;
            case "Vector3":
                {
                    this.addLine("gl_Position = s3_render_vertex(" + position + ");");
                }
                break;
            case "Vector4":
                {
                    this.addLine("gl_Position = s3_render_vertex(" + position + ".xyz);");
                }
                break;
        }
    };
    return GLSLVertexShaderGenerator;
}(glsl_1.ShaderGenerator));
exports.GLSLVertexShaderGenerator = GLSLVertexShaderGenerator;
var GLSLFragmentShaderGenerator = /** @class */ (function (_super) {
    __extends(GLSLFragmentShaderGenerator, _super);
    function GLSLFragmentShaderGenerator(parent) {
        var _this = _super.call(this) || this;
        _this._parent = parent;
        return _this;
    }
    GLSLFragmentShaderGenerator.prototype.addEmitStatement = function (sEmit) {
        this.addLine("gl_FragColor = " + this.generateExpression(sEmit.attributes.color) + ";");
    };
    return GLSLFragmentShaderGenerator;
}(glsl_1.ShaderGenerator));
exports.GLSLFragmentShaderGenerator = GLSLFragmentShaderGenerator;
var Generator = /** @class */ (function (_super) {
    __extends(Generator, _super);
    function Generator(spec, shader, asUniform, viewType, mode) {
        if (mode === void 0) { mode = GenerateMode.NORMAL; }
        var _this = _super.call(this, spec, shader, asUniform) || this;
        _this._mode = mode;
        _this._viewType = viewType;
        _this._vertex = new GLSLVertexShaderGenerator(_this);
        _this._fragment = new GLSLFragmentShaderGenerator(_this);
        _this.compile();
        return _this;
    }
    Generator.prototype.compile = function () {
        var _this = this;
        var spec = this._spec;
        var shader = this._shader;
        var asUniform = this._asUniform;
        this._voutMapping = new stardust_core_1.Dictionary();
        this._foutMapping = new stardust_core_1.Dictionary();
        this._vertex.addLine("precision highp float;");
        this._fragment.addLine("precision highp float;");
        if (this._mode == GenerateMode.PICK) {
            this._vertex.addAttribute("s3_pick_index", "Vector4");
            this._vertex.addUniform("s3_pick_index_alpha", "float");
        }
        switch (this._viewType) {
            case ViewType.VIEW_2D:
                {
                    this._vertex.addUniform("s3_view_params", "Vector4");
                    this._vertex.addAdditionalCode("\n            vec4 s3_render_vertex(vec3 p) {\n              return vec4(p.xy * s3_view_params.xy + s3_view_params.zw, 0.0, 1.0);\n            }\n          ");
                }
                break;
            case ViewType.VIEW_3D:
                {
                    this._vertex.addUniform("s3_view_params", "Vector4");
                    this._vertex.addUniform("s3_view_position", "Vector3");
                    this._fragment.addUniform("s3_view_position", "Vector3");
                    this._vertex.addUniform("s3_view_rotation", "Vector4");
                    this._vertex.addAdditionalCode("\n            vec4 s3_render_vertex(vec3 p) {\n              // Get position in view coordinates:\n              vec3 v = p - s3_view_position;\n              float d = dot(s3_view_rotation.xyz, v);\n              vec3 c = cross(s3_view_rotation.xyz, v);\n              v = s3_view_rotation.w * s3_view_rotation.w * v - (s3_view_rotation.w + s3_view_rotation.w) * c + d * s3_view_rotation.xyz - cross(c, s3_view_rotation.xyz);\n              // Compute projection.\n              vec4 r;\n              r.xy = v.xy * s3_view_params.xy;\n              r.z = v.z * s3_view_params.z + s3_view_params.w;\n              r.w = -v.z;\n              return r;\n            }\n          ");
                }
                break;
            case ViewType.VIEW_MATRIX:
                {
                    // Use the MVP matrix provided by it.
                    this._vertex.addUniform("s3_projection_matrix", "Matrix4");
                    this._vertex.addUniform("s3_view_matrix", "Matrix4");
                    this._vertex.addUniform("s3_view_position", "Vector3");
                    this._vertex.addUniform("s3_view_rotation", "Vector4");
                    this._vertex.addAdditionalCode("\n            vec4 s3_render_vertex(vec3 p) {\n              vec3 v = p - s3_view_position;\n              float d = dot(s3_view_rotation.xyz, v);\n              vec3 c = cross(s3_view_rotation.xyz, v);\n              v = s3_view_rotation.w * s3_view_rotation.w * v - (s3_view_rotation.w + s3_view_rotation.w) * c + d * s3_view_rotation.xyz - cross(c, s3_view_rotation.xyz);\n              return s3_projection_matrix * s3_view_matrix * vec4(v, 1);\n            }\n          ");
                }
                break;
        }
        if (this._viewType == ViewType.VIEW_2D) {
            [this._vertex, this._fragment].forEach(function (x) {
                return x.addAdditionalCode("\n          vec3 s3_get_camera_position() {\n            return vec3(0, 0, 1);\n          }\n          vec3 s3_get_camera_direction(vec3 p) {\n            return vec3(0, 0, 1);\n          }\n        ");
            });
        }
        else {
            [this._vertex, this._fragment].forEach(function (x) {
                x.addUniform("s3_camera_position", "Vector3");
                x.addAdditionalCode("\n          vec3 s3_get_camera_position() {\n            return s3_camera_position;\n          }\n          vec3 s3_get_camera_direction(vec3 p) {\n            return normalize(s3_camera_position - p);\n          }\n        ");
            });
        }
        // Input attributes.
        for (var name_2 in spec.input) {
            if (spec.input.hasOwnProperty(name_2)) {
                if (asUniform(name_2)) {
                    this._vertex.addUniform(name_2, spec.input[name_2].type);
                }
                else {
                    this._vertex.addAttribute(name_2, spec.input[name_2].type);
                }
            }
        }
        this._vertex.addLine("@additionalCode");
        // Output attributes.
        for (var name_3 in spec.output) {
            if (spec.output.hasOwnProperty(name_3)) {
                var oname = this.getUnusedName(name_3);
                this._voutMapping.set(name_3, oname);
                this._vertex.addVarying(oname, spec.output[name_3].type);
            }
        }
        // Fragment shader inputs
        var fragment_passthrus = []; // gname, input_name
        for (var name_4 in shader.input) {
            if (shader.input.hasOwnProperty(name_4)) {
                if (this.fragmentPassthru(name_4)) {
                    if (this._asUniform(name_4)) {
                        this._fragment.addUniform(name_4, shader.input[name_4].type);
                    }
                    else {
                        var gname = this.getUnusedName(name_4);
                        fragment_passthrus.push([gname, name_4]);
                        this._vertex.addVarying(gname, shader.input[name_4].type);
                        this._fragment.addVarying(gname, shader.input[name_4].type);
                    }
                }
                else {
                    var gname = this._voutMapping.get(name_4);
                    if (gname) {
                        this._fragment.addVarying(gname, shader.input[name_4].type);
                    }
                    else {
                        this._fragment.addUniform(name_4, shader.input[name_4].type);
                    }
                }
            }
        }
        if (this._mode == GenerateMode.PICK) {
            this._vertex.addVarying("out_pick_index", "Vector4");
        }
        // The main function.
        this._vertex.addLine("void main() {");
        this._vertex.indent();
        // Define arguments.
        for (var name_5 in spec.variables) {
            if (spec.variables.hasOwnProperty(name_5)) {
                var type = spec.variables[name_5];
                this._vertex.addDeclaration(name_5, type);
            }
        }
        this._vertex.addStatements(spec.statements);
        this._vertex.unindent();
        this._vertex.addLine("}");
        this._vertexCode = this._vertex.getCode();
        if (this._mode == GenerateMode.PICK) {
            this._fragmentCode = "\n        precision highp float;\n        varying vec4 out_pick_index;\n        void main() {\n          gl_FragColor = out_pick_index;\n        }\n      ";
        }
        else {
            // Input attributes.
            // Output attributes.
            for (var name_6 in shader.output) {
                if (shader.output.hasOwnProperty(name_6)) {
                    var oname = this.getUnusedName(name_6);
                    this._foutMapping.set(name_6, oname);
                    this._fragment.addDeclaration(oname, shader.output[name_6].type);
                }
            }
            this._fragment.addLine("@additionalCode");
            // The main function.
            this._fragment.addLine("void main() {");
            this._fragment.indent();
            // Define arguments.
            for (var name_7 in shader.variables) {
                if (shader.variables.hasOwnProperty(name_7)) {
                    var type = shader.variables[name_7];
                    this._fragment.addDeclaration(name_7, type);
                }
            }
            var _loop_1 = function (name_8) {
                if (shader.input.hasOwnProperty(name_8)) {
                    if (this_1.fragmentPassthru(name_8)) {
                        fragment_passthrus.forEach(function (_a) {
                            var gname = _a[0], vname = _a[1];
                            if (vname == name_8) {
                                _this._fragment.addLine(name_8 + " = " + gname + ";");
                            }
                        });
                    }
                    else {
                        if (this_1._voutMapping.get(name_8)) {
                            this_1._fragment.addDeclaration(name_8, shader.input[name_8].type);
                            this_1._fragment.addLine(name_8 + " = " + this_1._voutMapping.get(name_8) + ";");
                        }
                    }
                }
            };
            var this_1 = this;
            for (var name_8 in shader.input) {
                _loop_1(name_8);
            }
            this._fragment.addStatements(shader.statements);
            this._fragment.unindent();
            this._fragment.addLine("}");
            this._fragmentCode = this._fragment.getCode();
        }
    };
    Generator.prototype.getVertexCode = function () {
        return this._vertexCode;
    };
    Generator.prototype.getFragmentCode = function () {
        return this._fragmentCode;
    };
    return Generator;
}(glsl_1.ProgramGenerator));
exports.Generator = Generator;
//# sourceMappingURL=generator.js.map