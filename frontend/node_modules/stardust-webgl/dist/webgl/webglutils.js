"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stardust_core_1 = require("stardust-core");
function compileProgram(GL, vsCode, fsCode) {
    // Vertex shader
    var vsShader = GL.createShader(GL.VERTEX_SHADER);
    GL.shaderSource(vsShader, vsCode);
    GL.compileShader(vsShader);
    var success = GL.getShaderParameter(vsShader, GL.COMPILE_STATUS);
    if (!success) {
        console.log("Vertex shader code is:", vsCode);
        throw new stardust_core_1.RuntimeError("could not compile vertex shader: " + GL.getShaderInfoLog(vsShader));
    }
    // Fragment shader
    var fsShader = GL.createShader(GL.FRAGMENT_SHADER);
    GL.shaderSource(fsShader, fsCode);
    GL.compileShader(fsShader);
    success = GL.getShaderParameter(fsShader, GL.COMPILE_STATUS);
    if (!success) {
        console.log("Fragment shader code is:", fsCode);
        throw new stardust_core_1.RuntimeError("could not compile fragment shader: " + GL.getShaderInfoLog(fsShader));
    }
    // Link the program
    var program = GL.createProgram();
    GL.attachShader(program, vsShader);
    GL.attachShader(program, fsShader);
    GL.linkProgram(program);
    if (!GL.getProgramParameter(program, GL.LINK_STATUS)) {
        console.log("Vertex shader code is:", vsCode);
        console.log("Fragment shader code is:", fsCode);
        throw new stardust_core_1.RuntimeError("could not link shader: " + GL.getProgramInfoLog(program));
    }
    return program;
}
exports.compileProgram = compileProgram;
//# sourceMappingURL=webglutils.js.map